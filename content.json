{"meta":{"title":"安卓猴","subtitle":"把简单的事情做好。","description":"我使用的编程语言主要为Java和Python","author":"安卓猴","url":"http://sunjiajia.com"},"pages":[{"title":"关于我","date":"2016-05-03T10:31:20.000Z","updated":"2016-05-02T23:37:08.000Z","comments":true,"path":"about/index.html","permalink":"http://sunjiajia.com/about/index.html","excerpt":"","text":"昵称：安卓猴 认准头像 邮箱： 安卓猴邮箱 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号"},{"title":"categories","date":"2017-08-16T01:50:51.000Z","updated":"2016-11-09T10:31:43.000Z","comments":false,"path":"categories/index.html","permalink":"http://sunjiajia.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2017-08-16T01:50:51.000Z","updated":"2015-05-10T01:28:18.000Z","comments":true,"path":"search/index.html","permalink":"http://sunjiajia.com/search/index.html","excerpt":"","text":""},{"title":"","date":"2017-08-16T01:50:51.000Z","updated":"2016-11-09T10:31:03.000Z","comments":false,"path":"tags/index.html","permalink":"http://sunjiajia.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"VirtualBox中CentOS配置git服务器","slug":"virtualbox-centos-ssh-git-server","date":"2017-07-10T04:11:52.000Z","updated":"2017-07-10T08:18:32.000Z","comments":true,"path":"2017/07/10/virtualbox-centos-ssh-git-server/","link":"","permalink":"http://sunjiajia.com/2017/07/10/virtualbox-centos-ssh-git-server/","excerpt":"","text":"前言在管理自己的代码的时候，我一直使用github。有的时候，私有项目不想公开，如果还要放到GitHub上，那就必须要花钱。解决这个问题的方法其实也很简单：在自己电脑上用虚拟机（VirtualBox）跑一个服务器（CentOS），配置好ssh和git server。正所谓：史上距离你最近的服务器。 配置SSHSSH是程序员链接服务器的居家必备之花露水啊！因此在VirtualBox中安装好CentOS（最小化安装）后，首要工作就是配置它的SSH。 安装SSH 更新系统： 1yum update 安装openssh-server： 1yum install -y openssl openssh-server 启动SSH服务： 1systemctl start sshd.service 设置开机启动ssh服务： 1systemctl enable sshd.service 配置免密登录1.在客户端系统（我的是Mac）终端中生成密钥：1ssh-keygen -t rsa -C &quot;gitopen@gmail.com&quot; 注意输入自己的邮箱 2.会提示输入密码，但也可以留空（至少我是留空，输入密码太麻烦）。 3.完成后会在.ssh目录下生成id_rsa和id_rsa.pub两个密钥文件。 注意保存这两个文件，哪怕你换了电脑，重做了系统，也要记得备份。 4.查看VirtualBox中CentOS的ip地址：\b运行CentOS，\broot用户登录\b后输入：1ip addr 如图所示： CentOS ip地址 5.在客户端中用ssh连接CentOS：1ssh root@xxx.xxx.xxx.xxx -p 22 xxx.xxx.xxx.xxx是CentOS的ip地址，此时还需要输入CentOS的root账户密码。\b此时\b之所用SSH登录，是为了方便拷贝密钥到authorized_keys。 6.在VirtualBox中的CentOS服务器中进行配置：123456//创建.ssh文件夹：mkdir .ssh//创建authorized_keys文件：touch .ssh/authorized_keys//修改authorized_keys的权限：chmod 600 .ssh/authorized_keys 7.在客户端（Mac）中查看id_rsa.pub，并复制其中的密钥。1cat .ssh/id_rsa.pub 8.在CentOS中打开\bauthorized_keys，将刚才复制的密钥粘贴进去。1vi .ssh/authorized_keys 9.配置完毕了。 客户端（Mac）配置CentOS别名1.为VirtualBox中CentOS的网络设置端口转发设置网络类型为NAT，如图所示： CentOS NAT网络 设置端口转发，如图所示： CentOS 端口转发 \b以上操作是为了在客户端（Mac）中设置别名登录的时候，将ip地址写为127.0.0.1，避免每次启动CentOS自动获取ip\b的变化，需要修改太麻烦。 2.客户端（Mac）配置CentOS的别名1vi .ssh/config 输入以下：1234Host cent HostName 127.0.0.1 User root Port 4444 cent为别名，可以自由设置。 很方便的连接CentOS1ssh cent 配置和安装git服务器 所有操作可在客户机（Mac）上用SSH连接CentOS进行 1.CentOS安装最新git，依赖库安装12yum install curl-devel expat-devel gettext-devel openssl-devel zlib-develyum install gcc perl-ExtUtils-MakeMaker 2.卸载低版本Git1yum remove git 3.创建git目录并进入123\bcd /usr/localmkdir gitcd git 4.下载最新版Git 2.13.21wget https://github.com/git/git/archive/v2.13.2.tar.gz 截至目前最新版是2.13.2，可以到https://github.com/git/git/releases 复制最新版链接进行下载。 5.解压到git目录中1tar -xzvf v2.13.2.tar.gz 6.安装v2.13.2版Git123cd git-2.13.2make prefix=/usr/local/git allmake prefix=/usr/local/git install 编译过程稍微较长，耐心等待 7.添加到环境变量中打开/etc/profile1vi /etc/profile 加入1export PATH=&quot;/usr/local/git/bin:$PATH&quot; 使\b配置立即生效1source /etc/profile 8.查看\bgit版本1git --version 9.将最新版git设置为系统默认，避免克隆时出错12ln -s /usr/local/git/bin/git-upload-pack /usr/bin/git-upload-pack ln -s /usr/local/git/bin/git-receive-pack /usr/bin/git-receive-pack 10.最新版v2.13.2 Git安装成功 创建git用户组和添加用户1.添加用户组合用户\b，并设置密码123groupadd gituseradd git -g gitpasswd git 切换到git账户1su -git 2.证书登录，免密码\b使用git 创建.ssh目录和.ssh/authorized_keys文件，将\b客户端（Mac）的id_rsa.pub中的密钥添加到authorized_keys文件中 修改目录和文件的权限12chmod 700 .sshchmod 600 .ssh/authorized_keys 初始化Git仓库1.我的所有仓库都放在gitrepos目录下，因此我创建了这个目录123cd /home/gitmkdir gitreposcd gitrepos 2.初始化第一个test仓库1git init --bare test.git 本地客户端克隆仓库在客户端（Mac）上克隆CentOS\b上的test.git库1git clone git@cent:/gitrepos/test.git cent是章节2.3中设置的CentOS的SSH连接别名，也可以换成\b相应的ip地址 禁止Shell登录 如果你是在远程的VPS服务器上配置git服务器，那么为了安全考虑，可以禁止Shell登录；如果像本文的初衷那样，是为了构建\b\b史上距离你最近的服务器，那么这一步就可以不做。 切换到root账户：1su 编辑/etc/passwd文件：1vi /etc/passwd 将这一行：1git:x:502:502::/home/git:/bin/bash 替换为：1git:x:502:502::/home/git:/usr/local/git/bin/git-shell 结语通过用Virtualbox在本机上构建CentOS，方便于开发人员进行测试；通过在CentOS上搭建自己的Git服务器，可以将自己独立开发的代码很好的管理与备份。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Python","slug":"Python","permalink":"http://sunjiajia.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://sunjiajia.com/tags/Python/"},{"name":"CentOS","slug":"CentOS","permalink":"http://sunjiajia.com/tags/CentOS/"}]},{"title":"淘宝商品信息定向爬虫","slug":"taobao-spider","date":"2017-03-07T04:11:52.000Z","updated":"2017-05-25T15:28:53.000Z","comments":true,"path":"2017/03/07/taobao-spider/","link":"","permalink":"http://sunjiajia.com/2017/03/07/taobao-spider/","excerpt":"","text":"前言最近在学习数据分析的时候，提前学习了爬虫，其实在很早之前就学习过Python了，但是后来学习Android了，没有将Python很好的实践。但是学习了爬虫之后，我觉得自己写爬虫收集数据，放在自己的服务器上，然后再用自己的App展示出来，就不用再苦于没有数据了。但是，要想写出好的爬虫，也是一件不容易的事情，需要多加练习。 这次写这个淘宝商品信息定向爬虫仅仅是为了练习一下一些爬虫的常用方法，这里它涉及了如下的知识点： 爬虫的一个常用思路； Python的requests库和正则表达式的用法； pymongo以及mongoDB的用法； tkinter的用法； xlsxwriter库以及导出数据到Excel文件的用法； matplotlib库画出统计图表的用法。 此外，还需要有一台自己的VPS，并且会用Linux，配置好MongoDB服务器。这里推荐我在用的VPS服务商，使用下面的连接购买他家的服务，会得到一定的价钱优惠：强推本站VPS！优惠 效果展示 淘宝定向爬虫图1 这个是界面，提供了数据库服务器的一些必填参数，用于连接MongoDB服务器；还有数据的保存方式，提供了保存到数据库和导出到Excel文件两种方式；同时，还提供了画出简单的数据图表的功能。 淘宝定向爬虫图2 图2展示了Excel文件的命名规则。 淘宝定向爬虫图3 图3是使用Robomongo这个工具来看一下MongoDB中我们爬取到的数据。 淘宝定向爬虫图4 一共4400条数据。 淘宝定向爬虫图5 Excel文件中的数据展示。 Matplolib线性图 将数据用Matplolib线性图来表示。 Matplolib柱状图 将数据用Matplolib柱状图来表示。 Matplolib散点图 将数据用Matplolib散点图来表示。 思路过程明确需求我们的目标就是，在淘宝中用关键词搜索商品，然后将结果列表中的所有单个项的信息爬取出来，存储到MongoDB或者Excel文件中，最终画出数据图表。 例如，我们在淘宝中搜索美食，会得到100页数据，每个页面中的单个商品项一共是44个。 获取目标链接我们需要获取到淘宝的搜索页面的连接，用来作为Python爬虫的入口。当我们在淘宝主页中输入美食搜索后，得到一个链接： https://s.taobao.com/search?q=%E7%BE%8E%E9%A3%9F&amp;imgfile=&amp;commend=all&amp;ssid=s5-e&amp;search_type=item&amp;sourceId=tb.index&amp;spm=a21bo.50862.201856-taobao-item.1&amp;ie=utf8&amp;initiative_id=tbindexz_20170505 如图： 淘宝定向爬虫图6 但是这个链接我们可以这样来分析：将其中的一系列参数逐个去除，看看结果页面是否有变化，如果没有变化，那么说明这个参数是多余的，可以去除。 去除多余后的连接，并访问它：https://s.taobao.com/search?q=%E7%BE%8E%E9%A3%9F 其实，%E7%BE%8E%E9%A3%9F就是美食被编码后的字符串。 接着，我们来看一下，当我们选择了第3页后，链接有什么变化：https://s.taobao.com/search?q=%E7%BE%8E%E9%A3%9F&amp;bcoffset=3&amp;ntoffset=0&amp;p4ppushleft=1%2C48&amp;s=88 如图操作： 淘宝定向爬虫图7 同样的方法，我们把其中的参数逐个去除，得到了一个最简的连接：https://s.taobao.com/search?q=%E7%BE%8E%E9%A3%9F&amp;s=88 其中，s=88表示第3页，那么我们推测，s=44表示第2页，s=0表示第1页。在浏览器中访问这几个链接：https://s.taobao.com/search?q=%E7%BE%8E%E9%A3%9F&amp;s=0https://s.taobao.com/search?q=%E7%BE%8E%E9%A3%9F&amp;s=44 我们发现，正如我们推测的那样。 到这里，我们得到了入口链接的基本形式：https://s.taobao.com/search?q=`关键词`&amp;s=`页面商品个数` 更进一步，我们想到，可以用Python的Requests库来访问这个链接，得到我们想要的页面信息。 明确需要哪些数据如图，途中的一个Item中，包含了我们要提取的信息： 淘宝定向爬虫图8 如何拿到数据当我们访问到页面的时候，在页面空白处单击右键，进行查看源代码。然后，我们得到了这样的信息： 淘宝定向爬虫图9 我们可以从中看到，淘宝是通过js解析json数据来展示页面的。于是，我们把下面的json字符串拿来格式化以下，如下图： 淘宝定向爬虫图10 从中，我们看到了我们想要的数据的字段。哈哈，这样数据就很容易获取到了。 拿到数据这里，由于数据是以json字符串的形式返回的，我们用正则表达式匹配出来想要的信息，岂不是可以提高获取数据的速度~~ 12345678titles = re.findall(r'\\\"raw_title\\\":\\\".*?\\\"', html)prices = re.findall(r'\\\"view_price\\\":\\\"[\\d.]*\\\"', html)deals = re.findall(r'\\\"view_sales\\\":\\\"[0-9]*[1-9][0-9]*[\\u4e00-\\u9fa5]+\\\"', html)pics = re.findall(r'\\\"pic_url\\\":\\\".*?\"', html)detailurls = re.findall(r'\\\"detail_url\":\\\".*?\\\"', html)locations = re.findall(r'\\\"item_loc\\\":\\\"\\D*?\\\"', html)shops = re.findall(r'\\\"nick\\\":\\\".*?\\\"', html)shopurls = re.findall(r'\\\"shopLink\\\":\\\".*?\\\"', html) 写代码思路已经分析完毕，这里给出源代码，代码中有必要的注释，可以参考。如果看不太明白，可以动手敲一敲代码。源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468import threadingimport requestsimport reimport pymongoimport tkinter as tkfrom tkinter import messageboximport timeimport xlsxwriterimport matplotlib.pyplot as pltimport numpy as npimport random# from pylab import *is_running = Falsedef get_html(url): ''' 访问url链接，取得html源码并返回 :param url: url链接地址 :return: 获取正常，返回html源码；出现异常，返回None ''' try: user_agent = 'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.101 Safari/537.36' headers = &#123;'User_agent': user_agent&#125; r = requests.get(url, headers=headers) r.raise_for_status() r.encoding = \"utf-8\" return r.text except Exception as e: info = \"获取html出现异常：\\n\" + str(e) print(info) print_info(info) return Nonedef parse_data(result, html): ''' 从html中提取每个信息，并格式化为字典，存储在result这个列表中的同时，保存到数据库中去 :param result: 结果列表 :param html: html源码 ''' try: titles = re.findall(r'\\\"raw_title\\\":\\\".*?\\\"', html) prices = re.findall(r'\\\"view_price\\\":\\\"[\\d.]*\\\"', html) deals = re.findall( r'\\\"view_sales\\\":\\\"[0-9]*[1-9][0-9]*[\\u4e00-\\u9fa5]+\\\"', html) pics = re.findall(r'\\\"pic_url\\\":\\\".*?\"', html) detailurls = re.findall(r'\\\"detail_url\":\\\".*?\\\"', html) locations = re.findall(r'\\\"item_loc\\\":\\\"\\D*?\\\"', html) shops = re.findall(r'\\\"nick\\\":\\\".*?\\\"', html) shopurls = re.findall(r'\\\"shopLink\\\":\\\".*?\\\"', html) for i in range(len(titles)): product = &#123; 'title': eval(str(titles[i].split(\":\")[1])), 'price': eval(str(prices[i].split(\":\")[1])), 'deal': eval(str(deals[i].split(\":\")[1]))[:-3], 'pic': \"https:\" + eval(str(pics[i].split(\":\")[1])), 'detailurl': (\"https:\" + eval(str(detailurls[i].split(\":\")[1])) ).encode(\"unicode_escape\").decode(\"unicode_escape\"), 'location': eval(str(locations[i].split(\":\")[1])), 'shop': eval(str(shops[i].split(\":\")[1])), 'shopurl': \"https:\" + eval(str(shopurls[i].split(\":\")[1])).encode( \"unicode_escape\").decode(\"unicode_escape\") &#125; print(product) result.append(product) except Exception as e: info = \"提取信息出现异常：\\n\" + str(e) print(info) print_info(info)def save_to_db(dburl, dbport, dbname, dbuser, dbpwd, dbtable, products): info = \"正在保存数据到数据库。\" print_info(info) print(info) client = pymongo.MongoClient(host=dburl, port=int(dbport)) if dbuser and dbpwd: client['admin'].authenticate(dbuser, dbpwd, dbname, 'DEFAULT') db = client[dbname] try: db[dbtable].insert_many(products) except Exception as e: info = \"保存到数据库出现异常：\\n\" + str(e) + \"\\n\" print_info(info) print(info) info = \"保存到数据库成功。\" print_info(info) print(info)def spider_crawl(dburl, dbport, dbname, dbuser, dbpwd, dbtable, keyword, depth, mode): link = \"https://s.taobao.com/search?q=\" + keyword + \"&amp;sort=sale-desc\" products = [] for i in range(int(depth)): info = \"正在读取第 \" + str(i + 1) + \" 页。\" print_info(info) print(info) try: url = link + \"&amp;s=\" + str(44 * i) html = get_html(url) parse_data(products, html) except Exception as e: info = \"spider_crawl出现异常：\\n\" + str(e) print_info(info) print(info) continue result_info = \"爬取完毕，共获取到 \" + str(len(products)) + \" 条商品信息。\" print_info(result_info) print(result_info) if mode == 1: save_to_db(dburl, dbport, dbname, dbuser, dbpwd, dbtable, products) elif mode == 2: write_to_excel(keyword, dbname, dbtable, products) elif mode == 3: save_to_db(dburl, dbport, dbname, dbuser, dbpwd, dbtable, products) write_to_excel(keyword, dbname, dbtable, products) info = \"提示：此次爬取信息过程完整结束。\" print_info(info) print(info) is_running = Falsedef write_to_excel(keyword, dbname, dbtable, products): # time.strftime('%Y-%m-%d_%H:%M:%S', time.localtime(time.time()) info = \"正在保存数据到Excel文件。\" print_info(info) print(info) filename = keyword + '_' + dbname + '_' + dbtable + '_' + time.strftime( \"%Y-%m-%d_%H-%M-%S\", time.localtime(time.time())) + '_' + str(len(products)) + '.xlsx' workbook = xlsxwriter.Workbook(filename) worksheet = workbook.add_worksheet() headers = [ '_id', 'title', 'price', 'deal', 'shop', 'location', 'pic', 'detailurl', 'shopurl' ] # headers = ['title', 'price', 'deal', 'shop', 'location'] header_row = 0 for header in headers: col = headers.index(header) worksheet.write(header_row, col, header) # worksheet.write_rich_string(data_row, col, str(_value)) data_row = 1 for product in products: for _key, _value in product.items(): col = headers.index(_key) if _key == '_id' or _key == 'pic' or _key == 'detailurl' or _key == 'shopurl': worksheet.write_rich_string(data_row, col, str(_value)) else: worksheet.write(data_row, col, str(_value)) data_row += 1 workbook.close() info = \"成功保存数据到Excel文件。\" print_info(info) print(info)def crawl(): is_running = True db_url = entry_db_url.get() db_port = entry_db_port.get() db_name = entry_db_name.get() db_user = entry_db_user.get() db_pwd = entry_db_pwd.get() db_table = entry_db_table.get() keyword = entry_keyword.get() depth = entry_depth.get() mode = var_radio.get() if mode == 0: messagebox.showerror(title='错误！', message='没有选择数据保存方式！') elif mode == 1 or mode == 3: if db_url and db_port and db_name and db_table and keyword and depth: if int(depth) &gt; 100: depth = 100 elif int(depth) &lt;= 0: depth = 1 run_in_thread(spider_crawl, db_url, db_port, db_name, db_user, db_pwd, db_table, keyword, depth, mode) else: messagebox.showerror(title='错误！', message='如果您的数据库不需要登录，则④⑤两项可以不填；否则，①~⑧项必须全部填写！') elif mode == 2: if keyword and depth: run_in_thread(spider_crawl, db_url, db_port, db_name, db_table, keyword, depth, mode) else: messagebox.showerror(title='错误！', message='⑦⑧项必须全部填写！')def run_in_thread(func, *args): t = threading.Thread(target=func, args=args) t.setDaemon(True) t.start()def exit_app(): if is_running: messagebox.showerror(title='不能退出！', message='程序还在运行，请等待程序运行完毕后再退出。') else: root.quit()def print_info(info): result_text.insert('end', \"\\n\" + info + \"\\n------------------------------------\") result_text.see(\"end\")def radio_selector(): return var_radio.get()def read_from_db(): dburl = entry_db_url.get() dbport = entry_db_port.get() dbname = entry_db_name.get() dbuser = entry_db_user.get() dbpwd = entry_db_pwd.get() dbtable = entry_db_table.get() client = pymongo.MongoClient(host=dburl, port=int(dbport)) if dbuser and dbpwd: client['admin'].authenticate(dbuser, dbpwd, 'admin', 'DEFAULT') db = client[dbname] items = db[dbtable].find(&#123;&#125;, &#123;'price': 1, 'deal': 1, '_id': 0&#125;) results = &#123;&#125; for item in items: results[item['deal']] = item['price'] return resultsdef show_linear_chart(): # mpl.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签 # mpl.rcParams['axes.unicode_minus'] = False # 用来正常显示负号 datas = read_from_db() max_deal = max(datas.keys(), key=lambda x: int(x)) min_deal = min(datas.keys(), key=lambda x: int(x)) max_price = max(datas.values(), key=lambda x: float(x)) min_price = min(datas.values(), key=lambda x: float(x)) y_ticks = np.linspace(int(min_deal), int(max_deal), 10, endpoint=False) x_ticks = np.linspace(float(min_price), float(max_price), 10, endpoint=False) plt.figure() plt.title(\"线性图表\",fontproperties='SimHei',fontsize=20,color='green') plt.xlabel(\"商品价格（元）\",fontproperties='SimHei',fontsize=15,color='green') plt.ylabel(\"商品销量（件）\",fontproperties='SimHei',fontsize=15,color='green') ax = plt.gca() ax.set_xticks(x_ticks) ax.set_yticks(y_ticks) # y, x = zip(*sorted(datas.items())) # plt.plot(x, y) # plt.plot(*zip(*sorted(datas.items()))) new_list = zip(datas.values(), datas.keys()) new_datas = sorted(new_list, key=lambda x: float(x[0])) # print(new_datas) x, y = zip(*new_datas) plt.plot(x, y) plt.show()def show_scatter_chart(): datas = read_from_db() max_deal = max(datas.keys(), key=lambda x: int(x)) min_deal = min(datas.keys(), key=lambda x: int(x)) max_price = max(datas.values(), key=lambda x: float(x)) min_price = min(datas.values(), key=lambda x: float(x)) y_ticks = np.linspace(int(min_deal), int(max_deal), 10, endpoint=False) x_ticks = np.linspace(float(min_price), float(max_price), 10, endpoint=False) plt.figure() plt.title(\"散点图表\",fontproperties='SimHei',fontsize=20,color='green') plt.xlabel(\"商品价格（元）\",fontproperties='SimHei',fontsize=15,color='green') plt.ylabel(\"商品销量（件）\",fontproperties='SimHei',fontsize=15,color='green') ax = plt.gca() ax.set_xticks(x_ticks) ax.set_yticks(y_ticks) new_list = zip(datas.values(), datas.keys()) new_datas = sorted(new_list, key=lambda x: float(x[0])) # print(new_datas) # y, x = zip(*sorted(datas.items())) x, y = zip(*new_datas) plt.scatter(x, y, c='r') plt.show()def show_bar_chart(): # 随着价格的升高，销量的变化 datas = read_from_db() max_deal = max(datas.keys(), key=lambda x: int(x)) min_deal = min(datas.keys(), key=lambda x: int(x)) max_price = max(datas.values(), key=lambda x: float(x)) min_price = min(datas.values(), key=lambda x: float(x)) y_ticks = np.linspace(int(min_deal), int(max_deal), 10, endpoint=False) x_ticks = np.linspace(float(min_price), float(max_price), 10, endpoint=False) plt.figure() plt.title(\"柱状图表\",fontproperties='SimHei',fontsize=20,color='green') plt.xlabel(\"商品价格（元）\",fontproperties='SimHei',fontsize=15,color='green') plt.ylabel(\"商品销量（件）\",fontproperties='SimHei',fontsize=15,color='green') ax = plt.gca() ax.set_xticks(x_ticks) ax.set_yticks(y_ticks) # new_list = zip(datas.values(), datas.keys()) new_list = sorted(zip(datas.values(), datas.keys()), key=lambda x: float(x[0])) sample = random.sample(new_list, int(len(new_list) * 0.3)) sorted_sample = sorted(sample, key=lambda x: float(x[0])) print(sorted_sample) x_list = [] y_list = [] for x, y in sorted_sample: x_list.append(float(x)) y_list.append(int(y)) plt.bar(x_list, y_list, width=5.0, facecolor='blue', edgecolor='') plt.show()title = '淘宝商品定向爬虫'author = 'Powered by 孙佳佳'font_normal_size = 14root = tk.Tk()root.title(title)root.geometry('820x700')root.anchor('center')root.resizable(0, 0)label_title = tk.Label(root, text=title, font=('', 26))label_title.pack(anchor='center')label_author = tk.Label(root, text=author, font=('', 14), fg='blue')label_author.place(x=300, y=50)label_db_url = tk.Label(root, text='①数据库地址：', font=('', font_normal_size))label_db_url.place(x=100, y=100)entry_db_url = tk.Entry(root, show=None, font=('', font_normal_size))entry_db_url.insert('end', '108.61.162.201')entry_db_url.place(x=250, y=100)label_db_port = tk.Label(root, text='②数据库端口：', font=('', font_normal_size))label_db_port.place(x=100, y=150)entry_db_port = tk.Entry(root, show=None, font=('', font_normal_size))entry_db_port.insert('end', '10000')entry_db_port.place(x=250, y=150)label_db_name = tk.Label(root, text='③数据库名称：', font=('', font_normal_size))label_db_name.place(x=100, y=200)entry_db_name = tk.Entry(root, show=None, font=('', font_normal_size))entry_db_name.insert('end', 'jack')entry_db_name.place(x=250, y=200)label_db_user = tk.Label(root, text='④数据库用户：', font=('', font_normal_size))label_db_user.place(x=100, y=250)entry_db_user = tk.Entry(root, show=None, font=('', font_normal_size))entry_db_user.insert('end', 'jack')entry_db_user.place(x=250, y=250)label_db_pwd = tk.Label(root, text='⑤数据库密码：', font=('', font_normal_size))label_db_pwd.place(x=100, y=300)entry_db_pwd = tk.Entry(root, show=None, font=('', font_normal_size))entry_db_pwd.insert('end', '1238912389')entry_db_pwd.place(x=250, y=300)label_db_table = tk.Label(root, text='⑥数据库表名：', font=('', font_normal_size))label_db_table.place(x=100, y=350)entry_db_table = tk.Entry(root, show=None, font=('', font_normal_size))entry_db_table.insert('end', 'coffee')entry_db_table.place(x=250, y=350)label_keyword = tk.Label(root, text='⑦商品关键词：', font=('', font_normal_size))label_keyword.place(x=100, y=400)entry_keyword = tk.Entry(root, show=None, font=('', font_normal_size))entry_keyword.insert('end', '黑咖啡')entry_keyword.place(x=250, y=400)label_depth = tk.Label(root, text='⑧深度≤100：', font=('', font_normal_size))label_depth.place(x=100, y=450)entry_depth = tk.Entry(root, show=None, font=('', font_normal_size))entry_depth.insert('end', '10')entry_depth.place(x=250, y=450)result_text = tk.Text(root, font=('', font_normal_size), width=53, height=8)result_text.place(x=100, y=500)button_run = tk.Button( root, text='开始爬取', font=('', font_normal_size), command=crawl)button_run.place(x=520, y=250)button_exit = tk.Button( root, text='退出程序', font=('', font_normal_size), command=exit_app)button_exit.place(x=640, y=250)button_tu_1 = tk.Button( root, text='线性图表', font=('', font_normal_size), command=show_linear_chart)button_tu_1.place(x=520, y=300)button_tu_2 = tk.Button( root, text='散点图表', font=('', font_normal_size), command=show_scatter_chart)button_tu_2.place(x=640, y=300)button_tu_3 = tk.Button( root, text='柱状图表', font=('', font_normal_size), command=show_bar_chart)button_tu_3.place(x=520, y=350)var_radio = tk.IntVar()radio_db = tk.Radiobutton( root, text='保存到数据库', variable=var_radio, value=1, font=('', font_normal_size))radio_db.place(x=520, y=100)radio_excel = tk.Radiobutton( root, text='导出到Excel文件', variable=var_radio, value=2, font=('', font_normal_size))radio_excel.place(x=520, y=150)radio_both = tk.Radiobutton( root, text='两种方式同时执行', variable=var_radio, value=3, font=('', font_normal_size))radio_both.place(x=520, y=200)root.mainloop() 淘宝定向爬虫源码下载 Github上源码下载谢谢star一下啊~ ^#^~~ 结语代码非常简单，用起来也很方便。大家有问题的话，可以看下面的联系方式找到我，我们一起讨论。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Python","slug":"Python","permalink":"http://sunjiajia.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://sunjiajia.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://sunjiajia.com/tags/爬虫/"}]},{"title":"自定义Toolbar添加双击事件","slug":"double-tap-toolbar","date":"2017-01-07T13:11:52.000Z","updated":"2017-01-07T13:29:43.000Z","comments":true,"path":"2017/01/07/double-tap-toolbar/","link":"","permalink":"http://sunjiajia.com/2017/01/07/double-tap-toolbar/","excerpt":"","text":"前言今天在播放器中，突然想到了如果列表项过多，那么用户手指连续滑着回到顶部未免太累！类似微信朋友圈的双击TitleBar返回顶部，既然微信这超级App都实现了，那还等什么呢？动手做起来吧。我们这里是双击Toolbar返回顶部，不仅如此，其实在回调方法中可以做自己想做的事情。 预览图 自定义Toolbar添加双击事件 SuperToolbar.java代码：12345678910111213141516171819202122232425262728293031323334353637383940414243public class SuperToolbar extends Toolbar implements TapListener.OnDoubleTapListener &#123; private OnTwoTapListener mOnTwoTapListener; private GestureDetector mDetector; public interface OnTwoTapListener &#123; void onTwoTap(); &#125; public void setOnTwoTapListener(OnTwoTapListener onTwoTapListener) &#123; mOnTwoTapListener = onTwoTapListener; &#125; public SuperToolbar(Context context) &#123; this(context, null); &#125; public SuperToolbar(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, android.support.v7.appcompat.R.attr.toolbarStyle); &#125; public SuperToolbar(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TapListener tapListener = new TapListener(this); mDetector = new GestureDetector(context, tapListener); &#125; @Override public void onDouble() &#123; mOnTwoTapListener.onTwoTap(); &#125; @Override public boolean onTouchEvent(MotionEvent ev) &#123; super.onTouchEvent(ev); mDetector.onTouchEvent(ev); return true; &#125;&#125; TapListener 是 GestureDetector.SimpleOnGestureListener 的子类，我们需要它的 onDoubleTap(MotionEvent e) 方法 , SuperToolbar 实现了TapListener.OnDoubleTapListener这个接口，用于触发 onDoubleTap 这个双击方法。 TapListener.java源码：123456789101112131415161718public class TapListener extends GestureDetector.SimpleOnGestureListener &#123; private OnDoubleTapListener mDoubleTapListener; public TapListener(OnDoubleTapListener onDoubleTapListener) &#123; mDoubleTapListener = onDoubleTapListener; &#125; public interface OnDoubleTapListener &#123; void onDouble(); &#125; @Override public boolean onDoubleTap(MotionEvent e) &#123; mDoubleTapListener.onDouble(); return true; &#125;&#125; 使用方法12345678910SuperToolbar toolbar = (SuperToolbar) actView.findViewById(R.id.tool_bar);toolbar.setOnTwoTapListener(new SuperToolbar.OnTwoTapListener() &#123; @Override public void onTwoTap() &#123; //我的一个工具显示Toast，在双击后让RecyclerView返回列表顶部 // 在这里可以干你自己想干的事情，whatever，who care！ mUtils.sToast(\"双击！双击！Toolbar！\"); mRecycler.smoothScrollToPosition(0); &#125;&#125;); 结语今天写的这两篇博文记录的代码都是非常简单实用，用起来也很方便。大家有问题的话，可以看下面的联系方式找到我，我们一起讨论。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"}]},{"title":"自定义RecyclerView监听滑动到底部Bottom","slug":"recycler-bottom","date":"2017-01-07T04:11:52.000Z","updated":"2017-01-07T13:31:49.000Z","comments":true,"path":"2017/01/07/recycler-bottom/","link":"","permalink":"http://sunjiajia.com/2017/01/07/recycler-bottom/","excerpt":"","text":"前言最近在做一个本地的万能播放器，需要监听RecyclerView滑动到底部，向用户提示已经滑动到最底部；看了网上其他童鞋的写法，比较繁琐。现在给出我的实现方法，非常简单实用，在监听回调方法中，可以做很多想做的事情： 1.提示用户已经到达底部（Snack或者Toast）； 2.可以加载更多（我最讨厌格外加一个item来显示加载更多，于是当到达底部后直接给Adapter添加数据就好）； 3.可以额外再添加一个控件，来实现快速返回顶部（由你自己实现）； 4.等等。。。。（只要你判断好了到达底部，就可以在底部做自己想干的事情）。 预览图 自定义RecyclerView监听滑动到底部Bottom SuperRecycler.java代码：123456789101112131415161718192021222324252627282930313233343536373839404142public class SuperRecycler extends RecyclerView &#123; private OnBottomCallback mOnBottomCallback; public interface OnBottomCallback &#123; void onBottom(); &#125; public void setOnBottomCallback(OnBottomCallback onBottomCallback) &#123; this.mOnBottomCallback = onBottomCallback; &#125; public SuperRecycler(Context context) &#123; this(context, null); &#125; public SuperRecycler(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public SuperRecycler(Context context, @Nullable AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; @Override public void onScrolled(int dx, int dy) &#123; if (isSlideToBottom()) &#123; mOnBottomCallback.onBottom(); &#125; &#125; /** * 其实就是它在起作用。 */ public boolean isSlideToBottom() &#123; return this != null &amp;&amp; this.computeVerticalScrollExtent() + this.computeVerticalScrollOffset() &gt;= this.computeVerticalScrollRange(); &#125;&#125; 使用方法12345678910SuperRecycler recycler = (SuperRecycler) mFraView.findViewById(R.id.recycler);GridLayoutManager manager = new GridLayoutManager(getActivity(), 2, GridLayoutManager.VERTICAL, false);recycler.setLayoutManager(manager);recycler.setAdapter(mAdt);recycler.setOnBottomCallback(new SuperRecycler.OnBottomCallback() &#123; @Override public void onBottom() &#123; Snackbar.make(recycler, \"滚动到了底部\", Snackbar.LENGTH_SHORT).show(); &#125;&#125;); 结语代码非常简单，用起来也很方便。大家有问题的话，可以看下面的联系方式找到我，我们一起讨论。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"}]},{"title":"Daily Tips（Updated）","slug":"daily-tips","date":"2016-05-07T05:30:37.000Z","updated":"2016-11-26T11:15:13.000Z","comments":true,"path":"2016/05/07/daily-tips/","link":"","permalink":"http://sunjiajia.com/2016/05/07/daily-tips/","excerpt":"","text":"意欲如何？ 这篇博文取名为“Daily Tips”，意为日常技巧、小技巧，意在记录开发中或者与电脑打交道过程中遇到的一些小问题及解决途径，这些小问题是值得记录但又无须长篇大论、深究的。 记录方式将以三级标题是问题，其下内容为答案的模式，简单明了。 本篇博文将不定时更新，每次更新会将博文时间提到修改之时。 如若各位有任何问题和看法，请及时评论或者[at]我微博讨论交流。 您的问题和答案采取后也可以出现在本篇微博中，会注明您的姓名和链接，为您带来流量。 正文开始 [No.001] ubuntu(linux)下查看Gtk版本（version）信息？ 打开终端输入以下命令即可： 1dpkg -l libgtk2.0-0 libgtk-3-0 得到如下反馈： 1234||/ Name Version Architecture Description+++-==============-============-============-=================================ii libgtk-3-0:amd 3.10.8-0ubun amd64 GTK+ graphical user interface libii libgtk2.0-0:am 2.24.23-0ubu amd64 GTK+ graphical user interface lib 其中3.10.8、2.24.23分别为gtk3、gtk2的版本信息。 [No.002] 重装ubuntu后终端terminal的Tab键无法自动补全！ 打开终端，输入命令： 1sudo gedit /etc/bash.bashrc (ubuntu13.04以上版本)在打开的文件中搜索以下代码，并修改为以下样子（就是将之前每行开头的#删除），保存退出问题解决： 1234567if ! shopt -oq posix; then if [-f /usr/share/bash-completion/bash_completion ]; then . /usr/share/bash-completion/bash_completion elif [ -f /etc/bash_completion]; then . /etc/bash_completion fifi (ubuntu12.04及老版本)将以下代码前的#去掉： 123if [ -f /etc/bash_completion ] &amp;&amp; ! shopt -oq posix; then . /etc/bash_completionfi [No.003] 老版本Ubuntu（12.04）中安装新nodejs！ 还有问题再看 作者链接 123sudo apt-get install curlcurl -sL https://deb.nodesource.com/setup | sudo bash -sudo apt-get install nodejs [No.004] Android Studio启动后提示External file changes sync may be slow The current inotify(7) watch limit is too low.1sudo gedit /etc/sysctl.conf 在文件中加入：12## Inotify Watches Limitfs.inotify.max_user_watches = 524288 参考官方网页：点击打开 [No.005] Ubuntu16.04下打开Eclipse后各种按钮太大 这个问题是由与Ubuntu16.04中，eclipse默认使用了gtk3的原因，解决问题如下： 在eclipse根目录的eclipse.ini配置文件中，添加如下配置： 12--launcher.GTK_version2 [No.006] Ubuntu16.04下编译Android源码的jdk问题 在最新版本的Ubuntu下编译Android源码，由于Ubuntu16.04默认舍弃了openjdk-7-jdk，所以在编译的时候会提示如下错误： 123456Checking build tools versions...************************************************************You asked for an OpenJDK 7 build but your version isjava version \"1.7.0_80\" Java(TM) SE Runtime Environment (build 1.7.0_80-b15) Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode).************************************************************build/core/main.mk:191: *** stop. Stop. 解决的办法就是，利用ppa在Ubuntu16.04下安装openjdk-7-jdk： 删除系统中所有与java有关的包： 1sudo apt-get remove openjdk-* icedtea-* icedtea6-* 给Xenial添加OpenJDK7的PPA，并更新包索引： 1sudo add-apt-repository ppa:openjdk-r/ppa &amp;&amp; sudo apt-get update 安装所有当前可用的更新，以确保需要的包准备就绪： 1sudo apt-get upgrade &amp;&amp; sudo apt-get dist-upgrade 安装openjdk7，以及所有Android构建所依赖的包： 1sudo apt-get install adb fastboot openjdk-7-jdk git ccache automake lzop bison gperf build-essential zip curl zlib1g-dev zlib1g-dev:i386 g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush schedtool dpkg-dev liblz4-tool make optipng maven python-mako python3-mako python python3 syslinux-utils google-android-build-tools-installer 更新一下java的环境变量，选择里面有openjdk-7的那一项： 1sudo update-alternatives --config java 这样再次编译源码，就不会出现jdk的version错误了。 关于如何编译Android源码（AOSP），请参考博文： 《编译Android5.1.1源码》 关于国内下载AOSP源码速度太慢，请参考博文： 《国内镜像加速Android源码下载》 [No.007] 解决Ubuntu16.04 字体太细发虚（表现在Chrome中浏览中文） 这个问题产生是由于Ubuntu 16.04 LTS 的默认中日韩字体packagefonts-noto-cjk有一个bug，如果网页没有把其页面语言指定为中日韩字体，那么会用细的字体来显示。解决方法如下： 删除系统自带的fonts-noto-cjk包： 1sudo apt-get remove fonts-noto-cjk 使用Ubuntu 开发团队的 Gunnar Hjalmarsson 制作的fonts-noto-cjk个人PPA，它修复了这个bug： 1sudo add-apt-repository ppa:gunnarhj/fonts-noto-cjk 刷新一下包索引： 1sudo apt-get update 安装修复了bug的fonts-noto-cjk包： 1sudo apt-get install fonts-noto-cjk [No.008] Android emulator 启动失败，提示错误：libGL error: unable to load driver: i965_dri.so 具体的错误详细信息是： 1234567891011121314151617181920212223242526Cannot launch AVD in emulator.Output:libGL error: unable to load driver: i965_dri.solibGL error: driver pointer missinglibGL error: failed to load driver: i965libGL error: unable to load driver: i965_dri.solibGL error: driver pointer missinglibGL error: failed to load driver: i965libGL error: unable to load driver: swrast_dri.solibGL error: failed to load driver: swrastX Error of failed request: GLXBadContext Major opcode of failed request: 155 (GLX) Minor opcode of failed request: 6 (X_GLXIsDirect) Serial number of failed request: 55 Current serial number in output stream: 54libGL error: unable to load driver: i965_dri.solibGL error: driver pointer missinglibGL error: failed to load driver: i965libGL error: unable to load driver: i965_dri.solibGL error: driver pointer missinglibGL error: failed to load driver: i965libGL error: unable to load driver: swrast_dri.solibGL error: failed to load driver: swrastX Error of failed request: GLXBadContext Major opcode of failed request: 155 (GLX) Minor opcode of failed r 2.解决方法如下：（Linux） 123cd ~/Android/Sdk/tools/lib64/libstdc++/mv libstdc++.so.6 libstdc++.so.6.bakln -s /usr/lib64/libstdc++.so.6 未完待续～～ 该博文会持续更新，记录遇到的问题与解决问题的方法，希望能够帮到大家。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"技术相关","slug":"技术相关","permalink":"http://sunjiajia.com/categories/技术相关/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"http://sunjiajia.com/tags/技巧/"}]},{"title":"Android M (API23) 中对权限的授权处理","slug":"android-m-permissions","date":"2016-04-19T08:16:27.000Z","updated":"2016-05-13T20:05:24.000Z","comments":true,"path":"2016/04/19/android-m-permissions/","link":"","permalink":"http://sunjiajia.com/2016/04/19/android-m-permissions/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com）安卓猴的微博（@安卓猴） 前言Android M的发布，最重要的提升就是权限的控制，这么多年来Android App的权限滥用状况将逐步得到改善。 在API 23中，如果我们将compileSdkVersion和targetSdkVersion同时指定为23，而且我们没有显式的提醒用户去授予权限， 那么将导致App运行的崩溃。 因此，接下来，就写一个原生的PermissionsUtil工具类，来解决这个问题。 重要权限列表 API 23提醒用户授予权限 另外，Android官方手册中也有描述，可以详细阅读：Permissions 效果 我喜欢用Gif动图来直观的展示效果！ API 23提醒用户授予权限 函数 ActivityCompat.checkSelfPermission(Activity,String) 检查相应权限是否被授权，被授权返回PERMISSION_GRANTED，否则返回PERMISSION_DENIED。 ActivityCompat.shouldShowRequestPermissionRationale(Activity,String) 该函数的用法，请参看下面代码中的注释。 ActivityCompat.requestPermissions(Activity,String[],int) 对权限字符串数组中的所有权限进行申请授权，如果用户选择了“never ask again”，则不会弹出系统的Permission申请授权对话框。 上面requestPermissions的回调ActivityCompat.OnRequestPermissionsResultCallback 这个回掉的作用，就是根据requestPermissions之后的授权结果，来控制授权。例如，对没有授权的权限进行再次申请授权等等。 代码 PermissionsUtil工具类 它的源码地址，谢谢star一下： PermissionsUtil工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * * * * * * =================================== * * * Copyright (c) 2016. * * * 作者：安卓猴 * * * 微博：@安卓猴 * * * 博客：http://sunjiajia.com * * * Github：https://github.com/opengit * * * * * * 注意**：如果您使用或者修改该代码，请务必保留此版权信息。 * * * =================================== * * * * * */package com.sunjiajia.monkeyandroid.utils;import android.Manifest;import android.app.Activity;import android.content.Context;import android.content.Intent;import android.content.SharedPreferences;import android.content.pm.PackageManager;import android.net.Uri;import android.provider.Settings;import android.support.design.widget.Snackbar;import android.support.v4.app.ActivityCompat;import android.view.View;import com.sunjiajia.monkeyandroid.R;import java.util.ArrayList;/** * 权限控制工具类： * 为了适配API23，即Android M 在清单文件中配置use permissions后，还要在程序运行的时候进行申请。 * * ***整个权限的申请与处理的过程是这样的： * *****1.进入主Activity，首先申请所有的权限； * *****2.用户对权限进行授权，有2种情况： * ********1).用户Allow了权限，则表示该权限已经被授权，无须其它操作； * ********2).用户Deny了权限，则下次启动Activity会再次弹出系统的Permisssions申请授权对话框。 * *****3.如果用户Deny了权限，那么下次再次进入Activity，会再次申请权限，这次的权限对话框上，会有一个选项“never ask again”： * ********1).如果用户勾选了“never ask again”的checkbox，下次启动时就必须自己写Dialog或者Snackbar引导用户到应用设置里面去手动授予权限； * ********2).如果用户未勾选上面的选项，若选择了Allow，则表示该权限已经被授权，无须其它操作； * ********3).如果用户未勾选上面的选项，若选择了Deny，则下次启动Activity会再次弹出系统的Permisssions申请授权对话框。 */public class PermissionsUtil &#123; // 状态码、标志位 private static final int REQUEST_STATUS_CODE = 0x001; private static final int REQUEST_PERMISSION_SETTING = 0x002; //常量字符串数组，将需要申请的权限写进去，同时必须要在Androidmanifest.xml中声明。 private static String[] PERMISSIONS_GROUP = &#123; Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.INTERNET, Manifest.permission.CAMERA, Manifest.permission.ACCESS_NETWORK_STATE, Manifest.permission.ACCESS_WIFI_STATE, Manifest.permission.RECORD_AUDIO, Manifest.permission.WRITE_CONTACTS &#125;; public static void checkAndRequestPermissions(final Activity activity) &#123; // 一个list，用来存放没有被授权的权限 ArrayList&lt;String&gt; denidArray = new ArrayList&lt;&gt;(); // 遍历PERMISSIONS_GROUP，将没有被授权的权限存放进denidArray for (String permission : PERMISSIONS_GROUP) &#123; int grantCode = ActivityCompat.checkSelfPermission(activity, permission); if (grantCode == PackageManager.PERMISSION_DENIED) &#123; denidArray.add(permission); &#125; &#125; // 将denidArray转化为字符串数组，方便下面调用requestPermissions来请求授权 String[] denidPermissions = denidArray.toArray(new String[denidArray.size()]); // 如果该字符串数组长度大于0，说明有未被授权的权限 if (denidPermissions.length &gt; 0) &#123; // 遍历denidArray，用showRationaleUI来判断，每一个没有得到授权的权限是否是用户手动拒绝的 for (String permission : denidArray) &#123; // 如果permission是用户手动拒绝的，则用SnackBar来引导用户进入App设置页面，手动授予权限 if (!showRationaleUI(activity, permission)) &#123; // 判断App是否是首次启动 if (!isAppFirstRun(activity)) &#123; Snackbar snackbar = Snackbar.make(activity.findViewById(R.id.btn_sdcard_avail), \"这次是真的需要去授权了\", Snackbar.LENGTH_INDEFINITE); snackbar.setAction(\"前往设置\", new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 进入App设置页面 Intent intent = new Intent(Settings.ACTION_APPLICATION_DETAILS_SETTINGS); Uri uri = Uri.fromParts(\"package\", activity.getPackageName(), null); intent.setData(uri); activity.startActivityForResult(intent, REQUEST_PERMISSION_SETTING); &#125; &#125;); snackbar.show(); &#125; &#125; break; &#125; requestPermissions(activity, denidPermissions); &#125; &#125; /** * 关于shouldShowRequestPermissionRationale函数的一点儿注意事项： * ***1).应用安装后第一次访问，则直接返回false； * ***2).第一次请求权限时，用户Deny了，再次调用shouldShowRequestPermissionRationale()，则返回true； * ***3).第二次请求权限时，用户Deny了，并选择了“never ask again”的选项时，再次调用shouldShowRequestPermissionRationale()时，返回false； * ***4).设备的系统设置中，禁止了应用获取这个权限的授权，则调用shouldShowRequestPermissionRationale()，返回false。 */ public static boolean showRationaleUI(Activity activity, String permission) &#123; return ActivityCompat.shouldShowRequestPermissionRationale(activity, permission); &#125; /** * 对权限字符串数组中的所有权限进行申请授权，如果用户选择了“never ask again”，则不会弹出系统的Permission申请授权对话框 */ public static void requestPermissions(Activity activity, String[] permissions) &#123; ActivityCompat.requestPermissions(activity, permissions, REQUEST_STATUS_CODE); &#125; /** * 用来判断，App是否是首次启动： * ***由于每次调用shouldShowRequestPermissionRationale得到的结果因情况而变，因此必须判断一下App是否首次启动，才能控制好出现Dialog和SnackBar的时机 */ public static boolean isAppFirstRun(Activity activity) &#123; SharedPreferences sp = activity.getSharedPreferences(\"config\", Context.MODE_PRIVATE); SharedPreferences.Editor editor = sp.edit(); if (sp.getBoolean(\"first_run\", true)) &#123; editor.putBoolean(\"first_run\", false); editor.commit(); return true; &#125; else &#123; editor.putBoolean(\"first_run\", false); editor.commit(); return false; &#125; &#125;&#125; AndroidManifest.xml中也要声明之前指定的权限 123456789&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\"/&gt;&lt;uses-permission android:name=\"android.permission.INTERNET\"/&gt;&lt;uses-permission android:name=\"android.permission.CAMERA\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt;&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\"/&gt;&lt;uses-permission android:name=\"android.permission.WRITE_CONTACTS\"/&gt; 用法这个工具类的用法非常简单，在SplashActivity中或者MainActivity中调用即可： 1PermissionsUtil.checkAndRequestPermissions(this); OvEr…最近一直在忙，博文更新较慢。。。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android新手","slug":"Android新手","permalink":"http://sunjiajia.com/categories/Android新手/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第15课Spinner和AutoCompleteTextView","slug":"monkey-android-15","date":"2016-04-11T13:50:27.000Z","updated":"2016-05-13T20:05:36.000Z","comments":true,"path":"2016/04/11/monkey-android-15/","link":"","permalink":"http://sunjiajia.com/2016/04/11/monkey-android-15/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com）安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： Spinner的用法 AutoCompleteTextView的用法 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/opengit/MonkeyAndroid Spinner的用法Spinner，俗称下拉列表，它提供了一组固定的值或选项，允许用户从中选择一个作为默认的状态。 AutoCompleteTextView的用法AutoCompleteTextView，自动完成文本框，用户在输入时给予补全提醒。 效果图 Spinner和AutoCompleteTextView Spinner和AutoCompleteTextView Activity的源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.sunjiajia.monkeyandroid;import android.os.Bundle;import android.support.annotation.Nullable;import android.widget.ArrayAdapter;import android.widget.AutoCompleteTextView;import android.widget.Spinner;/** * Created by monkey on 1/3/16. */public class SpinnerAutoCompleteTextViewActivity extends BaseActivity &#123; @Override public int giveViewResId() &#123; return R.layout.activity_spinner_autocompletetextview; &#125; private Spinner mSpinnerCity; private String[] mDatas; private AutoCompleteTextView tvAc; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); intViews(); initData(); confingViews(); &#125; private void confingViews() &#123; setSpinner(); setAutoCompleteTextView(); &#125; private void setAutoCompleteTextView() &#123; ArrayAdapter&lt;CharSequence&gt; adapter03 = ArrayAdapter.createFromResource(this, R.array.av_male, android.R.layout.simple_list_item_1); tvAc.setAdapter(adapter03); &#125; private void setSpinner() &#123; //通过适配器来进行动态的数据填充 // 第一种：/* ArrayAdapter&lt;String&gt; adapter01 = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_dropdown_item, mDatas); mSpinnerCity.setAdapter(adapter01);*/ ArrayAdapter&lt;CharSequence&gt; adapter02 = ArrayAdapter.createFromResource(this, R.array.city, android.R.layout.simple_list_item_1); mSpinnerCity.setAdapter(adapter02); &#125; private void intViews() &#123; mSpinnerCity = (Spinner) findViewById(R.id.spinner_city); tvAc = (AutoCompleteTextView) findViewById(R.id.tv_autocomplete); &#125; protected void initData() &#123; mDatas = new String[] &#123; \"动态数据Spinner\", \"北京\", \"上海\", \"深圳\", \"广州\", \"洛杉矶\", \"纽约\", \"华盛顿\" &#125;; &#125;&#125; 布局文件XML的源码12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center_horizontal\" android:orientation=\"vertical\" &gt; &lt;!-- android:entries=\"@array/av_male\" 用来绑定静态的array数据。 --&gt; &lt;Spinner android:id=\"@+id/spinner_male\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:entries=\"@array/av_male\" /&gt; &lt;Spinner android:layout_marginTop=\"30dp\" android:id=\"@+id/spinner_city\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; &lt;!-- android:completionThreshold=\"1\" 用来设置第几个字符开始提示； --&gt; &lt;AutoCompleteTextView android:id=\"@+id/tv_autocomplete\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:completionThreshold=\"1\" android:hint=\"请输入侍寝的女优名字\" /&gt;&lt;/LinearLayout&gt; values/arrays.xml源码12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;array name=\"av_male\"&gt; &lt;item&gt;静态数据Spinner&lt;/item&gt; &lt;item&gt;苍井空&lt;/item&gt; &lt;item&gt;苍小妹&lt;/item&gt; &lt;item&gt;苍二妹&lt;/item&gt; &lt;item&gt;朝桐光&lt;/item&gt; &lt;item&gt;朝小姐&lt;/item&gt; &lt;item&gt;朝美女&lt;/item&gt; &lt;item&gt;小泽玛利亚&lt;/item&gt; &lt;item&gt;小仓美女&lt;/item&gt; &lt;item&gt;西翔野&lt;/item&gt; &lt;item&gt;西门庆&lt;/item&gt; &lt;item&gt;孙静雅&lt;/item&gt; &lt;item&gt;孙悟空&lt;/item&gt; &lt;item&gt;波多野结衣&lt;/item&gt; &lt;item&gt;菠萝菠萝蜜&lt;/item&gt; &lt;/array&gt; &lt;array name=\"city\"&gt; &lt;item&gt;动态填充数据2&lt;/item&gt; &lt;item&gt;北京&lt;/item&gt; &lt;item&gt;上海&lt;/item&gt; &lt;item&gt;深圳&lt;/item&gt; &lt;item&gt;广州&lt;/item&gt; &lt;item&gt;洛杉矶&lt;/item&gt; &lt;item&gt;纽约&lt;/item&gt; &lt;item&gt;华盛顿&lt;/item&gt; &lt;/array&gt;&lt;/resources&gt; 下课这一节课，我们主要学习了Spinner和AutoCompleteTextView，希望能够在实际中加以运用！ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第14课ToggleButton和RatingBar","slug":"monkey-android-14","date":"2016-04-11T12:50:27.000Z","updated":"2016-05-13T20:05:44.000Z","comments":true,"path":"2016/04/11/monkey-android-14/","link":"","permalink":"http://sunjiajia.com/2016/04/11/monkey-android-14/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com）安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： ToggleButton的用法 RatingBar的用法 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/opengit/MonkeyAndroid ToggleButton的用法ToggleButton，状态开关按钮，例如ON/OFF，它允许用户在两者之间进行切换。Switch，开关，类似于生活中的白色墙壁开关。 RatingBar的用法RatingBar，它是SeekBar和ProgressBar的扩展，用星型来显示等级评定。 效果预览 ToggleButton和RatingBar Activity源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package com.sunjiajia.monkeyandroid;import android.os.Bundle;import android.support.annotation.Nullable;import android.widget.CompoundButton;import android.widget.RatingBar;import android.widget.Switch;import android.widget.Toast;import android.widget.ToggleButton;/** * Created by monkey on 1/2/16. */public class ToggleButtonRadioBarActivity extends BaseActivity implements CompoundButton.OnCheckedChangeListener, RatingBar.OnRatingBarChangeListener &#123; @Override public int giveViewResId() &#123; return R.layout.activity_togglebutton_radiobar; &#125; private ToggleButton mTb; private Switch mSwitch; private RatingBar mRb; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); mTb = (ToggleButton) findViewById(R.id.toggle_button); mSwitch = (Switch) findViewById(R.id.switch_button); mRb = (RatingBar) findViewById(R.id.rating_bar); mTb.setOnCheckedChangeListener(this); mSwitch.setOnCheckedChangeListener(this); mRb.setOnRatingBarChangeListener(this); &#125; /** * ToggleButton和Switch的事件监听 */ @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; switch (buttonView.getId()) &#123; case R.id.toggle_button: showToast(isChecked); break; case R.id.switch_button: showToast(isChecked); break; &#125; &#125; private void showToast(boolean isChecked) &#123; if (isChecked) &#123; Toast.makeText(ToggleButtonRadioBarActivity.this, \"开\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(ToggleButtonRadioBarActivity.this, \"关\", Toast.LENGTH_SHORT).show(); &#125; &#125; /** * RatingBar的事件监听方法 */ @Override public void onRatingChanged(RatingBar ratingBar, float rating, boolean fromUser) &#123; Toast.makeText(ToggleButtonRadioBarActivity.this, \"获得了#\" + rating + \"#星好评！\", Toast.LENGTH_SHORT) .show(); &#125;&#125; 布局文件xml源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;!-- android:textOff=\"关闭\" 用来设置关闭状态时的文字显示； android:textOn=\"打开\" 用来设置打开状态时的文字显示； android:checked=\"true\" true表示默认状态为打开，false表示默认状态为关闭。 --&gt; &lt;ToggleButton android:id=\"@+id/toggle_button\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:checked=\"true\" android:text=\"ToggleButton\" android:textOff=\"关闭\" android:textOn=\"打开\" /&gt; &lt;Switch android:id=\"@+id/switch_button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:text=\"Switch\" /&gt; &lt;!-- android:numStars=\"5\" 用来设置星型的个数； android:rating=\"1.5\" 默认选定的星型个数，可为小数； android:stepSize=\"0.5\" 用来设置星型改变时的步频。 注意： 如果设置了android:numStars，那么android:layout_width必须设置为wrap_content --&gt; &lt;RatingBar android:id=\"@+id/rating_bar\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:numStars=\"5\" android:rating=\"1.5\" android:stepSize=\"0.5\" /&gt;&lt;/LinearLayout&gt; 下课这一节课，我们主要学习了ToggleButton和RatingBar，前者在App的设置页面，后者在商店商品的评分方面，应用都是十分广泛的。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第13课CheckBox和RadioButton","slug":"monkey-android-13","date":"2016-04-11T11:50:27.000Z","updated":"2016-05-13T20:05:52.000Z","comments":true,"path":"2016/04/11/monkey-android-13/","link":"","permalink":"http://sunjiajia.com/2016/04/11/monkey-android-13/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com）安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： CheckBox的用法 RadioButton的用法 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/opengit/MonkeyAndroid 效果图 CheckBox和RadioButton CheckBox和RadioButton的用法CheckBox，复选框，它允许用户选择一个或者多个。RadioButton，单选按钮，只能选取一个选项。 xml文件源码： 一些用到的xml属性的含义已经在注释中给出。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"@dimen/activity_horizontal_margin\" android:gravity=\"center_horizontal\" android:orientation=\"vertical\" &gt; &lt;CheckBox android:id=\"@+id/checkbox_xiaoshuo\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"小说\" /&gt; &lt;CheckBox android:id=\"@+id/checkbox_youxi\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"游戏\" /&gt; &lt;CheckBox android:id=\"@+id/checkbox_dianying\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"电影\" /&gt; &lt;!-- 这里是一个1dp高度view，用做一个分割线 --&gt; &lt;View android:layout_width=\"match_parent\" android:layout_height=\"1dp\" android:background=\"@android:color/darker_gray\" /&gt; &lt;!-- android:checkedButton=\"@+id/radiobutton_apple\" 表示默认选中的RadioButton； android:orientation=\"horizontal\" 表示RadioGroup中的RadioButton的是竖直排列还是水平排列 --&gt; &lt;RadioGroup android:id=\"@+id/radio_group\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:checkedButton=\"@+id/radiobutton_apple\" android:orientation=\"horizontal\" &gt; &lt;RadioButton android:id=\"@+id/radiobutton_banana\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"香蕉\" /&gt; &lt;RadioButton android:id=\"@+id/radiobutton_apple\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"苹果\" /&gt; &lt;RadioButton android:id=\"@+id/radiobutton_orange\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"橘子\" /&gt; &lt;/RadioGroup&gt;&lt;/LinearLayout&gt; Activity中的源码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package com.sunjiajia.monkeyandroid;import android.os.Bundle;import android.support.annotation.Nullable;import android.widget.CheckBox;import android.widget.CompoundButton;import android.widget.RadioButton;import android.widget.RadioGroup;import android.widget.Toast;/** * Created by monkey on 1/1/16. * * 实现了CheckButton的接口CompoundButton.OnCheckedChangeListener * * 实现了RadioGroup的接口RadioGroup.OnCheckedChangeListener */public class CheckBoxRadioButtonActivity extends BaseActivity implements CompoundButton.OnCheckedChangeListener, RadioGroup.OnCheckedChangeListener &#123; @Override public int giveViewResId() &#123; return R.layout.activity_checkbox_radiobutton; &#125; private CheckBox mCbXs, mCbYx, mCbDy; private RadioGroup mRg; private RadioButton mRbBanana, mRbApple, mRbOrange; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); initViews(); configViews(); &#125; /** * 配置各种控件，在这里只是设置了绑定了监听事件 */ private void configViews() &#123; mCbXs.setOnCheckedChangeListener(this); mCbYx.setOnCheckedChangeListener(this); mCbDy.setOnCheckedChangeListener(this); mRg.setOnCheckedChangeListener(this); &#125; /** * init各种控件 */ private void initViews() &#123; mCbXs = (CheckBox) findViewById(R.id.checkbox_xiaoshuo); mCbYx = (CheckBox) findViewById(R.id.checkbox_youxi); mCbDy = (CheckBox) findViewById(R.id.checkbox_dianying); mRg = (RadioGroup) findViewById(R.id.radio_group); mRbBanana = (RadioButton) findViewById(R.id.radiobutton_banana); mRbApple = (RadioButton) findViewById(R.id.radiobutton_apple); mRbOrange = (RadioButton) findViewById(R.id.radiobutton_orange); &#125; /** * CheckBox的监听事件 */ @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; switch (buttonView.getId()) &#123; case R.id.checkbox_xiaoshuo: checkedShowToast(buttonView, isChecked); break; case R.id.checkbox_youxi: checkedShowToast(buttonView, isChecked); break; case R.id.checkbox_dianying: checkedShowToast(buttonView, isChecked); break; &#125; &#125; /** * RadioGroup的监听事件 */ @Override public void onCheckedChanged(RadioGroup group, int checkedId) &#123; switch (checkedId) &#123; case R.id.radiobutton_banana: radioGroupChecked(mRbBanana); break; case R.id.radiobutton_apple: radioGroupChecked(mRbApple); break; case R.id.radiobutton_orange: radioGroupChecked(mRbOrange); break; &#125; &#125; private void radioGroupChecked(RadioButton button) &#123; Toast.makeText(CheckBoxRadioButtonActivity.this, \"您选中了#\" + button.getText().toString() + \"#\", Toast.LENGTH_SHORT).show(); &#125; private void checkedShowToast(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; Toast.makeText(CheckBoxRadioButtonActivity.this, \"您选中了#\" + buttonView.getText().toString() + \"#\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(CheckBoxRadioButtonActivity.this, \"您取消了#\" + buttonView.getText().toString() + \"#\", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125; 下课这一节课，我们主要学习了CheckBox和RadioButton的用法，CheckBox主要用于多选或者全选的场景，RadioButton主要用于有限选项而且仅允许单选的场景。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第12课ImageView","slug":"monkey-android-12","date":"2016-04-11T10:50:27.000Z","updated":"2016-05-13T20:05:58.000Z","comments":true,"path":"2016/04/11/monkey-android-12/","link":"","permalink":"http://sunjiajia.com/2016/04/11/monkey-android-12/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com）安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： ImageView的用法 ImageView的XML属性 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/opengit/MonkeyAndroid ImageView的用法ImageView顾名思义，就是图片视图，用来显示静态图片。 12345678910111213141516171819202122&lt;ImageView android:id=\"@+id/imageview_normal\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:background=\"@android:color/black\" android:onClick=\"ivClicked\" android:src=\"@mipmap/super_dog\" /&gt;&lt;ImageView android:id=\"@+id/imageview_super\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:adjustViewBounds=\"true\" android:background=\"@android:color/black\" android:maxHeight=\"300dp\" android:maxWidth=\"300dp\" android:onClick=\"ivClicked\" android:src=\"@mipmap/super_dog\" /&gt; 效果图如下： ImageView效果图 ImageView的XML属性 android:src，设置ImageView要显示的图片； android:adjustViewBounds，是否保持宽高比，需要和maxWidth、maxHeight一起使用，否则单独使用没有效果； android:maxWidth，设置View的最大宽度； android:maxHeight，设置View的最大高度； 如果想设置图片固定大小，又想保持图片宽高比，需要这样设置： android:adjustViewBounds设置为true； android:maxWidth和android:maxHeight要设置； android:layout_width和android:layout_height设置为wrap_content。 android:scaleType是设置图片的填充方式，有以下用法： android:scaleType=”center”，按图片的原来size居中显示，当图片长/宽超过View的长/宽，则截取图片的居中部分显示 android:scaleType=”centerCrop”，按比例扩大图片的size居中显示，使得图片长(宽)等于或大于View的长(宽) android:scaleType=”centerInside”，将图片的内容完整居中显示，通过按比例缩小或原来的size使得图片长(宽)等于或小于View的长(宽) android:scaleType=”fitCenter”，把图片按比例扩大(缩小)到View的宽度，居中显示 android:scaleType=”fitEnd”，把图片按比例扩大(缩小)到View的宽度，显示在View的下部分位置 android:scaleType=”fitStart”，把图片按比例扩大(缩小)到View的宽度，显示在View的上部分位置 android:scaleType=”fitXY”，把图片按照指定的大小在View中显示 android:scaleType=”matrix”，用matrix来绘制 下课这一节课，我们主要学习了ImageView，不过它的功能有限，只能显示静态图片。在实际需求中，我们可能会用到更高级的用法，如显示圆形头像，或者动态的gif，又或者图片的缩放与缩略图等等，这些就需要我们自己取实现ImageView了，后面都会讲到。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第11课Button和ImageButton","slug":"monkey-android-11","date":"2015-12-09T10:50:27.000Z","updated":"2016-05-13T20:06:04.000Z","comments":true,"path":"2015/12/09/monkey-android-11/","link":"","permalink":"http://sunjiajia.com/2015/12/09/monkey-android-11/","excerpt":"","text":"转发请注明出处： 安卓猴的博客（http://sunjiajia.com） 安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： Button的用法 Button的样式 ImageButton的用法 点击事件的写法（之前已经讲过，不知还会否？） 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/opengit/MonkeyAndroid Button的用法 按钮，可以按下它，或者点击，由用户来执行一个动作或者操作。 Button的xml写法： 12345678910&lt;Button android:id=\"@+id/btn_btn\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:drawableLeft=\"@mipmap/ic_launcher\" android:onClick=\"btnClicked\" android:text=\"安卓猴是Button\" android:textSize=\"26sp\" /&gt; 上面使用的Button的xml属性介绍： android:layout_gravity=”center_horizontal” 代表当前Button的位置要水平居中； android:drawableLeft=”@mipmap/ic_launcher” 表示当前的Button中文字左边的一个小图标； android:onClick=”btnClicked” 点击事件的其中一个写法。 Button的样式这里用selector选择器来定义Button的样式，实现自定义的点击响应效果。 在res目录下新建一个drawable文件夹； 在drawable文件夹上右击鼠标，选择New，再选择Drawable Resource file，弹出对话框，输入文件名字为bg_btn，如图： 打开bg_btn.xml文件，里面的内容为，实现的效果为默认状态下是holo_blue_bright颜色，按下状态的颜色是holo_red_light： 1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@android:color/holo_red_light\" android:state_pressed=\"true\" /&gt; &lt;item android:drawable=\"@android:color/holo_blue_bright\" /&gt;&lt;/selector&gt; 其中的item标签，用来定义Button的不同状态下显示的drawable，它可以是图片或者颜色值，关于状态有如下几个： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt; &lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;&lt;!-- 默认时的背景图片--&gt; &lt;item android:drawable=\"@drawable/image1\" /&gt; &lt;!-- 没有焦点时的背景图片 --&gt; &lt;item android:state_window_focused=\"false\" android:drawable=\"@drawable/image2\" /&gt; &lt;!-- 非触摸模式下获得焦点并单击时的背景图片 --&gt; &lt;item android:state_focused=\"true\" android:state_pressed=\"true\" android:drawable= \"@drawable/image3\" /&gt;&lt;!-- 触摸模式下单击时的背景图片--&gt; &lt;item android:state_focused=\"false\" android:state_pressed=\"true\" android:drawable=\"@drawable/image4\" /&gt; &lt;!--选中时的图片背景--&gt; &lt;item android:state_selected=\"true\" android:drawable=\"@drawable/image5\" /&gt; &lt;!--获得焦点时的图片背景--&gt; &lt;item android:state_focused=\"true\" android:drawable=\"@drawable/image6\" /&gt; &lt;/selector&gt; ImageButton的用法12345678&lt;ImageButton android:onClick=\"btnClicked\" android:id=\"@+id/imagebtn\" android:layout_width=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:layout_height=\"wrap_content\" android:src=\"@mipmap/ic_launcher\" /&gt; android:src=&quot;@mipmap/ic_launcher&quot;用来设定ImageButton中的图片。 效果Gif下课这一节课，我们主要学习了Button和Button的样式以及ImageButton的简单用法。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第10课TextView和EditText","slug":"monkey-android-10","date":"2015-12-08T13:50:27.000Z","updated":"2016-05-13T20:06:16.000Z","comments":true,"path":"2015/12/08/monkey-android-10/","link":"","permalink":"http://sunjiajia.com/2015/12/08/monkey-android-10/","excerpt":"","text":"转发请注明出处： 安卓猴的博客（http://sunjiajia.com） 安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： TextView的用法 EditText的用法 登陆框实例 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/git0pen/MonkeyAndroid TextView的用法 顾名思义，TextView就是文字视图，即显示文字的控件。 TextView的xml写法： 123456789101112&lt;TextView android:id=\"@+id/tv_login\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:autoLink=\"all\" android:background=\"@android:color/holo_green_dark\" android:text=\"登陆Login\" android:textAllCaps=\"true\" android:textColor=\"@android:color/holo_red_dark\" android:textSize=\"30sp\" android:textStyle=\"bold\" /&gt; 在Activity中的onCreate方法中使用它： 12TextView mTextView = (TextView) findViewById(R.id.tv_login);mTextView.setText(\"我是登陆框\"); EditText的用法 输入文本框，它是用户和Android系统进行数据交换的窗口。 EditText有几个特点： EditText是TextView的之类，所以TextView的方法和特性同样存在于EditText中； 有两个常用的监听事件：addTextChangedListener 和 setOnEditorActionListener; 下面的代码，实现了一个只有界面的登陆框： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\" android:weightSum=\"1\" &gt; &lt;TextView android:id=\"@+id/tv_login\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:autoLink=\"all\" android:background=\"@android:color/holo_green_dark\" android:text=\"登陆Login\" android:textAllCaps=\"true\" android:textColor=\"@android:color/holo_red_dark\" android:textSize=\"30sp\" android:textStyle=\"bold\" /&gt; &lt;TableLayout android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_below=\"@id/image_view\" android:layout_margin=\"16dp\" android:stretchColumns=\"1\" &gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/text_view_uname\" android:layout_column=\"0\" android:text=\"用户名：\" android:textSize=\"16sp\" /&gt; &lt;EditText android:id=\"@+id/et_uname\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"1\" android:hint=\"不能为空\" /&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/text_view_pwd\" android:layout_column=\"0\" android:text=\"密码：\" android:textSize=\"16sp\" /&gt; &lt;EditText android:id=\"@+id/et_pwd\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"1\" android:ems=\"10\" android:hint=\"不能为空\" android:inputType=\"textPassword\" /&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_column=\"0\" android:layout_gravity=\"right\" android:layout_span=\"2\" android:orientation=\"horizontal\" &gt; &lt;Button android:id=\"@+id/btn_login\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"登陆\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"注册\" /&gt; &lt;/LinearLayout&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt;&lt;/LinearLayout&gt; 下课这一节课，我们学习了TextView和EditText，它们的xml属性和函数方法还有很多，还需要你在练习的时候，耐心琢磨。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第9课Toast土司","slug":"monkey-android-9","date":"2015-12-06T11:50:27.000Z","updated":"2016-05-13T20:06:22.000Z","comments":true,"path":"2015/12/06/monkey-android-9/","link":"","permalink":"http://sunjiajia.com/2015/12/06/monkey-android-9/","excerpt":"","text":"转发请注明出处： 安卓猴的博客（http://sunjiajia.com） 安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： Toast显示普通文本 Toast显示图片 Toast显示图片和文字 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/git0pen/MonkeyAndroid Toast显示普通文本 简称土司，它用来在当前app的界面上弹出一个提示信息，并且会自动消失。 看下Toast到底怎么写： 12Toast.makeText(this, \"我是短时间土司1号！我的显示时长是Toast.LENGTH_SHORT\", Toast.LENGTH_SHORT).show();Toast.makeText(this, \"我是长时间土司2号！我的显示时长是Toast.LENGTH_LONG\", Toast.LENGTH_LONG).show(); 注意： 将上述代码直接放到Activity的onCreate方法中，当Activity启动后，即可显示Toast。关于Activity以及它的方法（生命周期函数），我们今后会专门讲解。 Toast显示图片12345678910111213// Toast的一个实例Toast toast3 = new Toast(this);// 显示图片的控件ImageView，并且给它设置图片ImageView imageView = new ImageView(this);imageView.setImageResource(R.mipmap.ic_launcher);// 将图片控件设置到Toast中toast3.setView(imageView);// 设置Toast的显示时间长短toast3.setDuration(Toast.LENGTH_SHORT);// 设置Toast显示的位置toast3.setGravity(Gravity.TOP,10,10);// 让Toast显示出来toast3.show(); Toast显示图片和文字12345678910111213Toast toast4 = Toast.makeText(this, \"我是图文土司4号的文字\", Toast.LENGTH_SHORT);// 显示图片的控件ImageView，并且给它设置图片ImageView imageView2 = new ImageView(this);imageView2.setImageResource(R.mipmap.ic_launcher);// 获得Toast的布局LinearLayout toast4View = (LinearLayout) toast4.getView();// 设置此布局为横向的toast4View.setOrientation(LinearLayout.HORIZONTAL);// 将图片视图添加到此布局中的第一个位置toast4View.addView(imageView2, 0);// 设置Toast显示的位置toast4.setGravity(Gravity.RIGHT | Gravity.CENTER, 50, 100);toast4.show(); 下课这一节课，我们学习了一个最简单但是最常用的小控件Toast，关于它的用法也很简单，今后会经常用到，所以你一定会使用的很娴熟的。此外，利用最后一种显示图文的方法，我们可以随时设置自己需要的Toast样式。例如，你可以自定义个更加复杂的View，添加的Toast中去，动手试验一下吧！ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第8课FrameLayout、GridLayout","slug":"monkey-android-8","date":"2015-12-06T10:50:27.000Z","updated":"2016-05-13T20:06:28.000Z","comments":true,"path":"2015/12/06/monkey-android-8/","link":"","permalink":"http://sunjiajia.com/2015/12/06/monkey-android-8/","excerpt":"","text":"转发请注明出处： 安卓猴的博客（http://sunjiajia.com） 安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： FrameLayout的用法 GridLayout的用法 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/git0pen/MonkeyAndroid FrameLayout 帧布局，在这种布局下，每个添加的子控件都被放在布局的左上角，并覆盖在前一个子控件的上层；此外，FrameLayout中的子控件的位置不能被指定。 GridLayout 自Android4.0版本（API level 14）后，新增的网格布局。 注意：如果要达到网格的效果，推荐使用LinearLayout来实现，因为使用GridLayout会产生如下问题： 不能同时在(x,y)轴方向上进行控件的对齐； 当多层布局嵌套的时候会出现性能问题； 不能稳定地支持一些支持自由编辑布局的工具。 计算器界面 用GridLayout和Button模仿了一个计算器的按键界面。 计算器界面 布局源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" &gt; &lt;FrameLayout android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" &gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"北京\" android:textColor=\"#898989\" android:textSize=\"18sp\" /&gt; &lt;TextView android:id=\"@+id/textView2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"上海\" android:textColor=\"#108939\" android:textSize=\"22sp\" /&gt; &lt;TextView android:id=\"@+id/textView3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"广州\" android:textColor=\"#103339\" android:textSize=\"26sp\" /&gt; &lt;TextView android:id=\"@+id/textView4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"南京\" android:textColor=\"#efec1c\" android:textSize=\"26sp\" /&gt; &lt;TextView android:id=\"@+id/textView5\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"东莞\" android:textColor=\"#ff5e00\" android:textSize=\"30sp\" /&gt; &lt;TextView android:id=\"@+id/textView6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"深圳\" android:textColor=\"#ae00ff\" android:textSize=\"36sp\" /&gt; &lt;/FrameLayout&gt; &lt;GridLayout android:layout_width=\"wrap_content\" android:layout_height=\"0dp\" android:layout_gravity=\"center\" android:layout_weight=\"2\" android:columnCount=\"4\" android:rowCount=\"6\" &gt; &lt;Button android:id=\"@+id/button3\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"0\" android:layout_row=\"0\" android:text=\"C\" /&gt; &lt;Button android:id=\"@+id/button2\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"1\" android:layout_row=\"0\" android:text=\"DEL\" /&gt; &lt;Button android:id=\"@+id/button4\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"2\" android:layout_row=\"0\" android:text=\"/\" /&gt; &lt;Button android:id=\"@+id/button5\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"0\" android:layout_row=\"1\" android:text=\"7\" /&gt; &lt;Button android:id=\"@+id/button6\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"1\" android:layout_row=\"1\" android:text=\"8\" /&gt; &lt;Button android:id=\"@+id/button7\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"2\" android:layout_row=\"1\" android:text=\"9\" /&gt; &lt;Button android:id=\"@+id/button12\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"3\" android:layout_row=\"1\" android:text=\"-\" /&gt; &lt;Button android:id=\"@+id/button8\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"0\" android:layout_row=\"2\" android:text=\"4\" /&gt; &lt;Button android:id=\"@+id/button9\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"1\" android:layout_row=\"2\" android:text=\"5\" /&gt; &lt;Button android:id=\"@+id/button10\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"2\" android:layout_row=\"2\" android:text=\"6\" /&gt; &lt;Button android:id=\"@+id/button11\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"3\" android:layout_row=\"0\" android:text=\"*\" /&gt; &lt;Button android:id=\"@+id/button13\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"3\" android:layout_row=\"2\" android:text=\"+\" /&gt; &lt;Button android:id=\"@+id/button15\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"0\" android:layout_row=\"3\" android:text=\"1\" /&gt; &lt;Button android:id=\"@+id/button16\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"1\" android:layout_row=\"3\" android:text=\"2\" /&gt; &lt;Button android:id=\"@+id/button17\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"2\" android:layout_row=\"3\" android:text=\"3\" /&gt; &lt;Button android:id=\"@+id/button14\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"3\" android:layout_gravity=\"fill_vertical\" android:layout_row=\"3\" android:layout_rowSpan=\"2\" android:text=\"=\" /&gt; &lt;Button android:id=\"@+id/button18\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"0\" android:layout_columnSpan=\"2\" android:layout_gravity=\"fill_horizontal\" android:layout_row=\"4\" android:text=\"0\" /&gt; &lt;Button android:id=\"@+id/button19\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"2\" android:layout_row=\"4\" android:text=\".\" /&gt; &lt;TextView android:id=\"@+id/textView7\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"0\" android:layout_columnSpan=\"4\" android:layout_gravity=\"fill_horizontal\" android:layout_row=\"5\" android:gravity=\"center\" android:text=\"计算器\" android:textColor=\"#000000\" android:textSize=\"38sp\" /&gt; &lt;/GridLayout&gt;&lt;/LinearLayout&gt; 下课这一节课，我们学习了FrameLayout和GridLayout，它们的使用也需要很多技巧。此外，我们要在平时练习的时候多多敲代码，这样才能熟能生巧。 到这里，所有布局的知识都学习完毕了。接下来，我们就要一起学习各种缤纷的控件了！ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第7课RelativeLayout、TableLayout","slug":"monkey-android-7","date":"2015-12-05T23:50:27.000Z","updated":"2016-05-13T20:06:36.000Z","comments":true,"path":"2015/12/06/monkey-android-7/","link":"","permalink":"http://sunjiajia.com/2015/12/06/monkey-android-7/","excerpt":"","text":"转发请注明出处： 安卓猴的博客（http://sunjiajia.com） 安卓猴的微博（@安卓猴） 通过本节课可以学习到的内容： RelativeLayout以及它的相关属性 TableLayout以及它的特有属性 实例代码: 运行效果参见本课程示例App：安卓猴Demos github地址：https://github.com/git0pen/MonkeyAndroid RelativeLayout 顾名思义，RelativeLayout就是相对布局，置于其中的控件在摆放的时候需要相对于布局中的其它控件来摆放。 RelativeLayout相关属性 这些属性十分“众多”，因此大致了解即可，关键是在敲代码的过程中熟练运用。 — 属性 作用 第1组属性 相对属性 — — android:layout_below 将目标控件置于引用控件的下方 — android:layout_above 将目标控件置于引用控件的上方 — android:layout_toLeftOf 将目标控件置于引用控件的左方 — android:layout_toRightOf 将目标控件置于引用控件的右方 第2组属性 对齐属性 — — android:layout_alignTop 目标控件和引用控件的上边缘对齐 — android:layout_alignBottom 目标控件和引用控件的下边缘对齐 — android:layout_alignLeft 目标控件与引用控件的左边缘对齐 — android:layout_alignRight 目标控件与引用控件的右边缘对齐 — android:layout_alignBaseLine 基于基准线对其，基准线就是我们写英文字母那4行线的第三条 第3组属性 这组属性的值是 true 或者 false — — layout_alignParentRight 是否与父控件的右边缘对齐 — layout_alignParentLeft 是否与父控件的左边缘对齐 — layout_alignParentTop 是否与父控件的上边缘对齐 — layout_alignParentBottom 是否与父控件的下边缘对齐 第4组属性 中间属性 — — layout_centerInParent 与父控件在水平方向和垂直方向都对齐 — layout_centerVertical 与父控件在垂直方向都对齐 — layout_centerHorizontal 与父控件在水平方向都对齐 第5组属性 引用属性 — — layout_alignStart 引用其他控件，表示与控件的开始位置对齐 — layout_alignStop 引用其他控件，表示与控件的结束位置对齐 — layout_alignParentStart 取值为true、false，表示与父控件的开始位置对齐 — layout_alignParentStop 取值为true、false，表示与父控件的结束位置对齐 TableLayout 顾名思义，TableLayout布局就是表格布局。其实现的效果就如同上面的属性表格一样。 TableLayout的特有属性 android:stretchColumns=&quot;1&quot;设置所用行的第二列为扩展列,如果有三列的话，剩余空间由第二列补齐。 android:shrinkColumns=&quot;1&quot;设置所用行第二列为收缩列。 android:layout_column=&quot;0&quot;表示当前控件在表格中的第0列，视觉效果上是第1列。 android:layout_span=&quot;2&quot; 表示当前控件跨了两列。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/text_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentLeft=\"true\" android:layout_alignParentStart=\"true\" android:layout_alignParentTop=\"true\" android:background=\"#41c2fa\" android:text=\"我右边是Button\" android:textColor=\"#fc0000\" android:textSize=\"22sp\" /&gt; &lt;Button android:id=\"@+id/button\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignParentTop=\"true\" android:layout_gravity=\"center_horizontal\" android:layout_toEndOf=\"@+id/text_view\" android:layout_toRightOf=\"@+id/text_view\" android:text=\"我下边是ImageView\" /&gt; &lt;ImageView android:id=\"@+id/image_view\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_alignLeft=\"@+id/button\" android:layout_alignStart=\"@+id/button\" android:layout_below=\"@+id/button\" android:src=\"@mipmap/ic_launcher\" /&gt; &lt;TableLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_below=\"@id/image_view\" android:stretchColumns=\"1\" &gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/text_view_uname\" android:layout_column=\"0\" android:text=\"用户名：\" android:textSize=\"16sp\" /&gt; &lt;EditText android:id=\"@+id/edit_text_uname\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"1\" /&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/text_view_pwd\" android:layout_column=\"0\" android:text=\"密码：\" android:textSize=\"16sp\" /&gt; &lt;EditText android:id=\"@+id/editText\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_column=\"1\" android:ems=\"10\" android:inputType=\"textPassword\" /&gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;/TableRow&gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_column=\"0\" android:layout_gravity=\"right\" android:layout_span=\"2\" android:orientation=\"horizontal\" &gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"登陆\" /&gt; &lt;Button android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"注册\" /&gt; &lt;/LinearLayout&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt;&lt;/RelativeLayout&gt; 下课这一节课，我们学习了RelativeLayout和TableLayout的用法，其中前者是必须重点掌握的布局，后者是需要了解的布局；熟练灵活地使用RelativeLayout布局，可以让你在今后的项目开发中对UI的把控更加游刃有余。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"Gradle多渠道打包[umeng]","slug":"gradle-umeng-channels","date":"2015-09-01T23:50:27.000Z","updated":"2016-05-13T20:06:42.000Z","comments":true,"path":"2015/09/02/gradle-umeng-channels/","link":"","permalink":"http://sunjiajia.com/2015/09/02/gradle-umeng-channels/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 前言国内Android应用市场品种太多，血统不纯，每次上线App都打包打到手软，上传上到吐血！好在我们有了Android studio和gradle，一条命令打包各种渠道版本App！ 正文Umeng多渠道我们在项目中会使用统计SDK，用的最流行的当属umeng了吧。这里我们就用友盟来说明。用了友盟的App的清单文件AndroidManifest.xml中都会写上meta-data，来区分不同的渠道： 123&lt;meta-data android:name=\"UMENG_CHANNEL\" android:value=\"Channel_ID\" /&gt; 1.将Channel_ID更改为${UMENG_CHANNEL_VALUE}，如下： 123&lt;meta-data android:name=\"UMENG_CHANNEL\" android:value=\"$&#123;UMENG_CHANNEL_VALUE&#125;\" /&gt; 2.在app的build.gradle设置produceFlavors： 1234567891011121314151617productFlavors &#123; xiaomi &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"xiaomi\"] &#125; qihoo &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"qihoo\"] &#125; baidu &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"baidu\"] &#125; wandoujia &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"wandoujia\"] &#125; qq &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"qq\"] &#125;&#125; 3.来看看我在项目中使用的build.gradle文件内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120apply plugin: 'com.android.application'def releaseTime() &#123; return new Date().format(\"yyyy-MM-dd\", TimeZone.getTimeZone(\"UTC\"))&#125;android &#123; compileSdkVersion 23 buildToolsVersion \"23.0.0\" defaultConfig &#123; // 这里的applicationId根据自己的替换 applicationId \"com.sunjiajia.xxxxx\" minSdkVersion 14 targetSdkVersion 22 versionCode 1 versionName \"0.0.1\" multiDexEnabled true //dex突破65535限制 manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"umeng\"] &#125; lintOptions &#123; disable 'MissingTranslation', 'ExtraTranslation' abortOnError false &#125; signingConfigs &#123; // /home/monkey/Projects/AndroidStudioProjects/debug.jks是签名文件所在全路径 // debug时打包用的签名 debug &#123; keyAlias 'debug' keyPassword '123456' storeFile file('/home/monkey/Projects/AndroidStudioProjects/debug.jks') storePassword '123456' &#125; // release时打包用的签名 release &#123; keyAlias 'monkey' keyPassword '123123' storeFile file('/home/monkey/Projects/AndroidStudioProjects/monkey.jks') storePassword '123123' &#125; &#125; buildTypes &#123; debug &#123; // 显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"true\" versionNameSuffix \"-debug\" minifyEnabled false zipAlignEnabled false shrinkResources false signingConfig signingConfigs.debug &#125; release &#123; // 不显示Log buildConfigField \"boolean\", \"LOG_DEBUG\", \"false\" minifyEnabled true zipAlignEnabled true // 移除无用的resource文件 shrinkResources true proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def outputFile = output.outputFile if (outputFile != null &amp;&amp; outputFile.name.endsWith('.apk')) &#123; // 输出apk名称为appname_v1.0_2015-09-15_09-57-58_wandoujia.apk // 下面的appname改为你自己的app name def fileName = \"appname_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.productFlavors[0].name&#125;.apk\" output.outputFile = new File(outputFile.parent, fileName) &#125; &#125; &#125; &#125; &#125; packagingOptions &#123; exclude 'META-INF/DEPENDENCIES.txt' exclude 'META-INF/LICENSE.txt' exclude 'META-INF/NOTICE.txt' exclude 'META-INF/NOTICE' exclude 'META-INF/LICENSE' exclude 'META-INF/DEPENDENCIES' exclude 'META-INF/notice.txt' exclude 'META-INF/license.txt' exclude 'META-INF/dependencies.txt' exclude 'META-INF/LGPL2.1' &#125; // 友盟多渠道打包 productFlavors &#123; xiaomi &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"xiaomi\"] &#125; qihoo &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"qihoo\"] &#125; baidu &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"baidu\"] &#125; wandoujia &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"wandoujia\"] &#125; qq &#123; manifestPlaceholders = [UMENG_CHANNEL_VALUE: \"qq\"] &#125; &#125;&#125;dependencies &#123; testCompile 'junit:junit:4.12' compile 'com.android.support:appcompat-v7:23.0.1' compile 'com.android.support:design:23.0.1'&#125; 命令创建task1.进入项目的根目录： 12// 打包全部Debug版本./gradlew assembleDebug 12// 打包全部Release版本./gradlew assembleRelease 2.assemble和Product Flavor 结合创建指定渠道的任务版本。例如： 12// 打包wandoujia渠道的Release版本和Debug版本./gradlew assembleWandoujia 12// 打包wandoujia渠道的Release版本./gradlew assembleWandoujiaRelease 结语大家有什么问题，在下面留言就可以了，也可以关注我的微博@安卓猴，交流更及时。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"进阶","slug":"进阶","permalink":"http://sunjiajia.com/tags/进阶/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"}]},{"title":"Android >= 4.4 适配沉浸状态栏颜色","slug":"android-kitkat-translucent-statusbar","date":"2015-09-01T23:50:27.000Z","updated":"2016-05-13T20:06:50.000Z","comments":true,"path":"2015/09/02/android-kitkat-translucent-statusbar/","link":"","permalink":"http://sunjiajia.com/2015/09/02/android-kitkat-translucent-statusbar/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 前言Google的Material Design的发布让Android具备了更多的个性化元素，例如，“沉浸式”状态栏。问题来了，那么在低版本Android上可以用吗？ 其实，在Android &gt;= 4.4的版本中，都可以进行“沉浸式”状态栏适配的，只不过效果不太一样，Android &gt;= 5.0 版本中设置更加简单，Android &gt;= 4.4 但 &lt; 5就比较麻烦。 效果图： Android >= 4.4 Status Bar MIUI Status Bar Android 5.0+实现方法参见文章：《Android L+ Theme 与 Toolbar 实例》 Android 4.4 实现方法1.使用开源库SystemBarTint 2.然后在BaseActivity中的OnCreate方法中进行设置： 12345678910111213if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; Window mWindow = getWindow(); mWindow.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS, WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); mWindow.setFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION, WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); SystemBarTintManager mSystemBarTintManager = new SystemBarTintManager(this); mSystemBarTintManager.setStatusBarTintEnabled(true); mSystemBarTintManager.setNavigationBarTintEnabled(true); mSystemBarTintManager.setTintColor(Color.parseColor(\"#E03131\")); &#125; 结语文章比较简单，权当记录用吧。最近一直在独立开发一个项目，由于每天时间不多，进度也比较慢。新的App中适配了Material Design，极大的节省了UI的设计时间，况且我还是一个不懂PS的。有兴趣的话，可以交流。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"进阶","slug":"进阶","permalink":"http://sunjiajia.com/tags/进阶/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"}]},{"title":"体验极速Android Sdk更新与下载","slug":"tencent-bugly-android-sdk-mirror","date":"2015-08-16T07:50:27.000Z","updated":"2016-05-13T20:06:56.000Z","comments":true,"path":"2015/08/16/tencent-bugly-android-sdk-mirror/","link":"","permalink":"http://sunjiajia.com/2015/08/16/tencent-bugly-android-sdk-mirror/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 前言国内下载或者更新Android SDK的速度奇慢，福利来了，专门解决这个问题。 2015-09-07更新其他源部分网友反应，腾讯的Android SDK镜像不可用，再分享一个速度比较快的。 配置说明：东软信息学院开源镜像站 Android SDK 配置说明 2015-08-16更新腾讯Bugly Android SDk 镜像使用指南 腾讯Bugly Android SDk 镜像 地址 1.打开独立Android SDK 管理器，在Android Studio中打开**： 打开独立Android SDK 管理器 2.菜单依次打开Tools–&gt;Manage Add-on Sites...–&gt;User Defined Sites： User Defined Sites 3.输入下面链接： 1http://android-mirror.bugly.qq.com:8080/android/repository/addon.xml 4.进入SDK Manager的Settings中，按图片中进行设置： SDK Manager Settings 5.HTTP Proxy Server 和 HTTP Proxy Port分别输入的是： 12android-mirror.bugly.qq.com8080 6.菜单中选择Packages–&gt;Reload，进行刷新后，就可以下载或者更新你需要的SDK组件了！我这里电信小水管，直接满速，如图： Android SDK 下载满速 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android新手","slug":"Android新手","permalink":"http://sunjiajia.com/categories/Android新手/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"编译Android5.1.1源码","slug":"make-android-open-source","date":"2015-08-15T23:50:27.000Z","updated":"2016-05-13T20:07:02.000Z","comments":true,"path":"2015/08/16/make-android-open-source/","link":"","permalink":"http://sunjiajia.com/2015/08/16/make-android-open-source/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 前言编译Android源码是为了更好的学习源码，当然，如果要做第三方ROM适配，也可以尝试；我们这篇重点学习如下内容： 如何在Ubuntu下编译Android5.1.1源码； 导入Android Studio进行源码阅读。 今天你好吗配置编译环境1.需要Ubuntu 64bit，建议Ubuntu14.04 64-bit； 2.安装openJDK 7: 12$ sudo apt-get update$ sudo apt-get install openjdk-7-jdk 3.更新jDK环境变量： 12$ sudo update-alternatives --config java$ sudo update-alternatives --config javac 4.为Ubuntu安装必须的packages： 1$ sudo apt-get install bison g++-multilib git gperf libxml2-utils make python-networkx zlib1g-dev:i386 zip 开始编译1.进入源码根目录，加速下载源码的方法请移步：《国内镜像加速Android源码下载》： 1$ cd android_source 2.初始化编译环境： 1$ . build/envsetup.sh 3.选择编译目标，如果仅仅是为了阅读源码学习，就选择aosp_arm-eng： 1$ lunch 4.开始编译，这里使用了4个并发数： 1make -j4 5.漫长的等待，时间不等，根据硬件配置而定，大致需要2h～10h之间。 6.编译过程中，如果出现任何问题，直接Google就行了；我的经历是，出现错误是由于源码下载不完整，为了避免，请移步《国内镜像加速Android源码下载》。 7.编译成功后，终端会有如下提醒： 1#### make completed successfully (08:04:50 (hh:mm:ss)) #### 导入Android Studio1.编译完成后，在源码根目录下，执行： 1mmm development/tools/idegen/ 2.等待片刻，终端提示以下内容，说明android.iws, android.ipr, android.iml生成成功： 123456make: Entering directory `/home/monkey/Android/android-5.1.1_r3'host Java: idegen (out/host/common/obj/JAVA_LIBRARIES/idegen_intermediates/classes)Install: out/host/linux-x86/framework/idegen.jarmake: Leaving directory `/home/monkey/Android/android-5.1.1_r3'#### make completed successfully (9 seconds) #### 3.打开Android Studio，选择打开一个现有的Android Studio项目，选择Android源码的根目录,导入即可，这里起作用的是android.irp文件。在配置sdk版本之后就可以查看Android源码了。 4.提醒一下，常用Widgets的源码在/frameworks/base/core/java/android/widget目录结构下，也可以按ctrl+N寻找源码文件。 结束Android5.1.1源码下载完毕，也编译完毕，同时，也导入到Android Studio供我们欣赏源代码的美丽。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"进阶","slug":"进阶","permalink":"http://sunjiajia.com/tags/进阶/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"}]},{"title":"国内镜像加速Android源码下载","slug":"download-android-open-source-projects","date":"2015-08-13T23:50:27.000Z","updated":"2016-05-13T20:07:08.000Z","comments":true,"path":"2015/08/14/download-android-open-source-projects/","link":"","permalink":"http://sunjiajia.com/2015/08/14/download-android-open-source-projects/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 1.首先，感谢伟大的Google； 2.其次，感谢清华镜像； 3.最后，感谢小水管以及长城。 直接用小水管跨越长城下载Android source简直是和自己开玩笑。 清华大学镜像无论是Ubuntu源更新还是Android源码下砸，都是使用清华大学镜像。 Ubuntu源使用方法不多说了，不会的自行Google。 Android源码清华镜像使用方法官方介绍使用方法====点击浏览==== 我来介绍1.下载修改好的repo，====下载地址====，密码：rb5t； 2.打开终端，输入： 12mkdir ~/binPATH=~/bin:$PATH 3.将repo放入~/bin目录下； 4.赋予执行权限，终端输入： 1chmod a+x ~/bin/repo 5.建立android源码存放目录： 12mkdir android_sourcecd android_source 6.查看想要下载的源码的Tag和Builds，网址：====点击查看，需要翻蔷====，这里 @安卓猴 给你们截下图，自己放大查看： Android源码Tags和Builds 7.例如我要下载android-5.1.1_r3，就在终端输入： 1repo init -u git://aosp.tuna.tsinghua.edu.cn/android/platform/manifest -b android-5.1.1_r3 8.终端输入下面命令使用repo开始源代码下载同步，-j4表示并发数为4，清华镜像只支持最大并发数4： 1repo sync -j4 9.漫长的等待后，源码下载完毕。速度在200～800KB/s不等。 结束Android源码终于下载完毕，历程才刚刚开始，接下来的编译工作，才最考验耐心。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"进阶","slug":"进阶","permalink":"http://sunjiajia.com/tags/进阶/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"}]},{"title":"《Monkey Android》第6课点击事件的四种写法","slug":"monkey-android-6","date":"2015-08-09T23:50:27.000Z","updated":"2016-05-13T20:07:14.000Z","comments":true,"path":"2015/08/10/monkey-android-6/","link":"","permalink":"http://sunjiajia.com/2015/08/10/monkey-android-6/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 通过本节课可以学习到的内容： Button和TextView的简单使用 LinearLayout的用法 点击事件的4种写法 LinearLayout中的Button、TextView布局文件的源码： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"点击事件的4种写法\" android:textColor=\"#ff002e\" android:textSize=\"22sp\" /&gt; &lt;Button android:id=\"@+id/btn01\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"按钮01\" /&gt; &lt;Button android:id=\"@+id/btn02\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"按钮02\" /&gt; &lt;Button android:id=\"@+id/btn03\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"按钮03\" /&gt; &lt;Button android:id=\"@+id/btn04\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"clickButton04\" android:text=\"按钮04\" /&gt;&lt;/LinearLayout&gt; 布局文件解析LinearLayout： 将RelativeLayout改为LinearLayout，即线性布局； 它里面的控件成线性排列，竖直或者水平，用android:orientation=”vertical”或者android:orientation=”horizontal”来设置； android:gravity=”center”设置子控件全部居中； TextView: 用来显示文本的控件； android:text设置显示的内容； android:textColor设置字体颜色； android:textSize设置字体大小； Button： 按钮控件； android:onClick设置点击事件的方法名称； android:text设置按钮的文字； 点击事件的4种写法MainActivity源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.sunjiajia.firstdemo;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.view.View;import android.widget.Button;import android.widget.TextView;import android.widget.Toast;import butterknife.ButterKnife;public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private Button mButton01; private Button mButton02; private Button mButton03; private Button mButton04; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mButton01 = (Button) findViewById(R.id.btn01); mButton02 = (Button) findViewById(R.id.btn02); mButton03 = (Button) findViewById(R.id.btn03); mButton04 = (Button) findViewById(R.id.btn04); // 第1种写法： mButton01.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, mButton01.getClass().toString() +\"--&gt; Button01\", Toast.LENGTH_SHORT).show(); &#125; &#125;); // 第2种写法：主类实现OnClickListener接口，并在主类中复写方法onClick mButton02.setOnClickListener(this); // 第3种写法：内部类实现OnClickListener接口，复写方法onClick MyButtonClickListener mButtonClickListener = new MyButtonClickListener(); mButton03.setOnClickListener(mButtonClickListener); &#125; // 第4种写法：在布局文件中给Button04添加android:onClick=\"clickButton04\"属性，并指定了点击触发的方法clickButton04 public void clickButton04(View view) &#123; Toast.makeText(this, mButton04.getClass().toString() +\"--&gt; Button04\", Toast.LENGTH_SHORT).show(); &#125; class MyButtonClickListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, mButton03.getClass().toString() +\"--&gt; Button03\", Toast.LENGTH_SHORT).show(); &#125; &#125; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity.this, mButton02.getClass().toString() +\"--&gt; Button02\", Toast.LENGTH_SHORT).show(); &#125;&#125; 要点解析： 4种写法位于源码注释中，请敲代码体验； Toast为“土司”控件，即在Activity上显示一个弹出来的提示； mButton02.getClass().toString()得到控件对象的类名并转换为字符串； 总结我们在“Button”上按住“ctrl”键，并点击鼠标左键，跟踪到Button的源码类，发现它是继承于TextView，继续跟踪，发现TextView继承于View。实际上，Android中所有可视控件都是继承自View。 据此，我们可以推断出来，TextView也可以写点击事件，自己动手试试吧。 下课学习了本节课程，点击事件的4种写法已经讲解完毕。 有什么问题请在下面留言评论，我们一起进步！ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"我的开发环境","slug":"my-develop-environment","date":"2015-08-09T02:50:27.000Z","updated":"2016-05-13T20:07:20.000Z","comments":true,"path":"2015/08/09/my-develop-environment/","link":"","permalink":"http://sunjiajia.com/2015/08/09/my-develop-environment/","excerpt":"","text":"我的开发环境最近在写第二个系列文章《Monkey Android》，目标定位Android初学者，因此不得不谈论一下他们很关心的开发环境的问题。在系列文章中我并没有设计这方面的讨论，原因是过多的纠结于开发环境会使学习的时间成本大大增加。 在这篇文章中，我介绍一下自己的开发环境，各位初学者就浅尝辄止吧！ Windows还是Ubuntu？如果预算充足，那么用MBP最舒服；如果懒得折腾与适应，手边的Windows PC最方便；如果要找到一个平衡点，那么Ubuntu PC最适合。 Ubuntu昨天在我的Thinkpad上配置了基于Ubuntu系统的Android开发环境，用着非常顺手。 全新硬盘安装Ubuntu1.找一台Windows电脑，用软碟通将Ubuntu镜像iso写入一个空白U盘中； 2.引导从U盘启动，然后安装Ubuntu，我安装的是English版； 3.分区采用最简单最有效的方式：一个`/home`分区，一个`/`分区； 4.步骤3是为了重装系统时，不用动home分区，这样所有数据都在； 5.安装好后，切换为国内源，更新下系统； 这里给的步骤是粗略的，不懂可以Google之。 建立Android目录 我的JDK，Android SDK，Android Studio，包括工程目录，全部放在这里，方便寻找与使用。 配置环境变量在 ~/.profile中添加JDK的环境变量，还有sdk的platform-tools，方便adb等工具的使用： 1234567export JAVA_HOME=/home/monkey/Android/jdk1.8.0_51export JRE_HOME=/home/monkey/Android/jdk1.8.0_51/jreexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$PATHexport PATH=/home/monkey/Android/android-sdk/platform-tools/:$PATH 常用软件浏览器： Firefox和Chrome 终端模拟器： Terminator gcolor2： Ubuntu下取色器，全局取色，获取颜色代码。 haroopad: markdown编辑器，写博文和做笔记的必备。 ss: 结合浏览器的proxy等插件，愉快地上Google。 播放器： 学习过程少不了看各种视频教程，那么VLC绝对是最佳播放器。 文本编辑器： 如果感觉Ubuntu自带编辑器不好用，那么可以使用github的Atom编辑器，或者Sublime Text编辑器，不懂的记得Google一下就可以。 hexo博客学习编程一定要记笔记，那么，一个免费的博客是少不了的。 github pages + hexo 结语目前就想起来这么多，不会配置的直接Google一下，相信你一定能够找到理想答案。 有疑问请留言，问问题又不会怀孕。你说是吧？ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android新手","slug":"Android新手","permalink":"http://sunjiajia.com/categories/Android新手/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第5课之剖析第一个App","slug":"monkey-android-5","date":"2015-08-07T06:50:27.000Z","updated":"2016-05-13T20:07:26.000Z","comments":true,"path":"2015/08/07/monkey-android-5/","link":"","permalink":"http://sunjiajia.com/2015/08/07/monkey-android-5/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 通过本节课可以学习到的内容： 第一个App最重要的三个文件 MainAcivity.java代码分析 activity_main.xml代码分析 AndroidManifest.xml代码分析 最重要的三个文件我们的第一个项目FirstDemo.java建立以后，Android Studio首先展示给我们的就是activity_main.xml和MainAcivity.java源文件，另外，还有一个无比重要的文件AndroidMenifest.xml，下面我们着重理解这三个文件的作用以及代码的含义。 MainAcivity.java代码分析顾名思义，Main的意思是主要的，Acivity的意思是活动；那么，MainAcivity.java源文件的作用肯定就是： 主要的活动窗口。 贴一下它的主要代码： 123456789101112public class MainActivity extends AppCompatActivity &#123; /** * Activity启动的时候调用 * @param savedInstanceState */ @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125;&#125; 它有以下关键点： 1.MainActivity继承自类AppCompatActivity，它是做什么的？ 2.有一个复写（Override）的方法onCreate，为什么要复写它呢？ 3.setContentView()方法又是做什么的呢？ 4.R.layout.activity_main是什么意思？ AppCompatActivity从名字来看，Compat的意思是兼容，那么它的意思是App兼容Activity。 Android有很多版本，因此，Google为了向下兼容更多的版本，提供了很多兼容包、兼容类。 我们来跟踪一下AppCompatActivity的源码： 1.键盘长按Ctrl键，鼠标左键点击AppCompatActivity，AS会带我们来到AppCompatActivity类所在的源码位置； 2.我们发现，AppCompatActivity继承自FragmentActivity，继续跟踪下去，键盘长按Ctrl键，鼠标左键点击FragmentActivity； 3.我们来到了FragmentActivity所在源码的位置，惊奇的发现，原来它们都是继承自Activity。 现在我们弄清楚Activity是做什么的： 1.在官方手册中找到Activity的文档，地址 https://developer.android.com/reference/android/app/Activity.html 2.定位到Class Overview位置； 3.看到解释如下： An activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you in which you can place your UI with setContentView(View). 我给翻译一下就是： 所有在App中能看到的和做的都是在Activity上。 onCreate当Activity运行的时候，首先会调用这个方法，在它里面，需要用setContentView()方法来设置UI布局。另外，布局中的各种控件，都是在这里初始化的。 setContentViewsetContentView() 用来给Activity设置一个UI布局，即activity_main.xml，有了它，我们的App才能显示出各种各样的界面。 R.layout.activity_mainR是编译器为我们自动生成的一个文件，它里面是各种控件、布局等等的ID值，layout表示所引用的activity_main是一个布局文件，位于工程目录layout文件夹下。 activity_main.xml代码分析贴一下源码： 1234567891011&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;TextView android:id=\"@+id/textview\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/hello_world\" /&gt;&lt;/RelativeLayout&gt; RelativeLayout用来表示，这个一个相对布局，里面的控件都是按照相对的位置来拜访的，除此之外还有多种布局，以后会讲到； xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;是命名空间，有了它，就可以引用Android给我们提供好的控件属性； layout_width表示布局的宽，layout_height表示布局的高，有3种值：match_parent撑满父布局，wrap_content包裹内容，具体的数值例如200dp； 对于TextView来说，它是用来显示文本内容的，因此它有一个属性text，显示的内容是strings.xml文件中的键为hello_world的值，也可以直接在””中写上内容，不过不推荐； android:id=”@+id/textview”表示该TextView的id是textview，方便在Java代码中进行实例化初始化； @表示通过一个id引用一个内容，@+表示增加一个id； 将android:text=”@string/hello_world”改为android:text=”Hello 安卓猴”，再次运行下App看下效果。 AndroidManifest.xml代码分析贴一下源码： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.sunjiajia.firstdemo\" &gt; &lt;application android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:theme=\"@style/AppTheme\" &gt; &lt;activity android:name=\".MainActivity\" android:label=\"@string/app_name\" &gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; 顾名思义，由于manifest是清单的意思，所以AndroidManifest.xml就是Android清单文件，所有的Android四大组件都必须在这里进行声明。 android:icon表示App的图标； android:label表示App的标签，即名称； android:theme表示App的主题，不同个App有不同个样式主题，我们可以设置喜欢的主题； activity是四大组件之一，因此它毫不犹豫的出现在了这里； android:name表示activity的名字，例如MainActivity.java这个主Activity的name就是”.MainActivity”，.表示包名目录的根目录； intent-filter标签里面定义了一个action和一个category，action表示此Activity的动作是MAIN，就是主界面，第一个Activity；category表示此Acivity是一个启动器，显示在Launcher中； action和category同时作用表示该activity是App启动时加载的第一个Activity。 下课学习了本节课程，相信一定能够大致懂得第一个App里面不同文件的作用，为自己写出代码作铺垫。 有什么问题请在下面留言评论，我们一起进步！ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第4课之运行第一个App","slug":"monkey-android-4","date":"2015-08-03T00:50:27.000Z","updated":"2016-05-13T20:07:32.000Z","comments":true,"path":"2015/08/03/monkey-android-4/","link":"","permalink":"http://sunjiajia.com/2015/08/03/monkey-android-4/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 通过本节课可以学习到的内容： 运行第一个App 学习几个adb命令 在真机上运行它 隔空运行调试App 运行第一个App第1步 打开Android Studio，并打开上节课中我们创建的Genymotion模拟器，点击Android Studio的工具栏中的绿色实心向右箭头运行按钮，开始Build项目，稍等弹出设备选择界面，如图： 运行第一个App第1步 第2步 点击Next后，打开Android5.1模拟器，可以看到第一个App已经运行了！如图： 运行第一个App第2步 学习几个adb命令第1步 将SDK的platform-tools文件夹加入到系统环境变量中。 第2步 打开你的Genymotion模拟器，打开cmd命令行窗口，输入adb devices，得到反馈： 123List of devices attachedc6a98c05 device169.254.109.102:5555 device 有两个设备处于可用于调试app的状态，第一个是真机，第二个是Genymotion模拟器。 第3步 有时我们会遇到真机或者模拟器连接良好，但是调试运行时，Android Studio提示设备超时，这时，我们用到以下两个adb命令： 用来杀死adb服务: 1adb kill-server 用来开启adb服务: 1adb start-server 如果杀死并重启adb服务后，仍然无法调试，那么请重现连接的真机，或者重启模拟器。 在真机上运行它第1步 开启USB调试功能，过程如下： 设置 –&gt; 关于手机 –&gt; 狂点（系统version）–&gt; 提示已处于开发者模式 –&gt; 设置 –&gt; 开发者选项 –&gt; USB调试。 第2步 用USB数据线链接电脑和手机，如果驱动安装好了，手机状态栏中会显示已连接USB调试。如图： 在真机上运行第2步 第3步 打开cmd命令行，执行命令adb devices，得到如下反馈，说明真机连接成功： 12List of devices attachedc6a98c05 device 第4步 在我们的Android Studio中，按快捷键Shift + F10运行我们的项目App，弹出选择设备对话框，如图： 在真机上运行第4步 第5步 已经运行到真机上了！如图： 在真机上运行第5步 隔空运行调试App是不是每次插上数据线有种被绑定的感觉？那么，我们就隔空调试App！ 第1步 下载无线ADB调试的app到真机上并安装，下载地址： 无线ADB调试 这个是我反编译汉化国外大神的，对他表示感谢。 第2步 真机和电脑连接同一个WiFi，打开无线ADB调试app，并且给予ROOT权限，如图： 隔空运行调试App 第3步 打开cmd命令行，输入下面命令，adb服务连接到了真机，即可通过WiFi来调试App！ 1adb connect 192.168.199.115 下课学习了本节课程，相信你已经能够得心应手地将自己编写的App运行到设备上去了。 我们的准备工作到这里就结束了，下节课，我们将开始正式学习有关Android的编程知识。 多动手敲代码，是成为高手的最快途径。 有什么问题请在下面留言评论，我们一起进步！ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第3课之Android Studio简介与模拟器","slug":"monkey-android-3","date":"2015-08-02T13:50:27.000Z","updated":"2016-05-13T20:07:36.000Z","comments":true,"path":"2015/08/02/monkey-android-3/","link":"","permalink":"http://sunjiajia.com/2015/08/02/monkey-android-3/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 通过本节课可以学习到的内容： Android Studio新建工程 初识Android Studio真面目 用Android模拟器运行Android 5.1.1系统 Android Studio新建工程第1步： 打开Android Studio，点击Start a New Android Studio project。如图： 新建工程第1步 第2步： 按照图中解释，填写 Application Name 等信息。如图： 新建工程第2步 第3步： 选择App的运行设备类型和相应的系统版本。如图： 新建工程第3步 第4步： 选择新建Activity的类型，我们保持默认。如图： 新建工程第4步 第5步： 需要填写Activity Name等信息，我们依旧保持默认。如图： 新建工程第5步 第6步： 点击Finish后，Android Studio开始新建工程，初次使用由于要下载gradle等组件，速度较慢，请耐心等待。 初识Android Studio真面目再等待一段时间后，工程终于建立完毕，这时，我们看到了Android Studio的真面目，以及它的默认布局，如图： Android Studio真面目 模拟器原生模拟器在我们的学习当中，不建议使用原生模拟器，因为它容易出现掉线、卡机等未知问题，但是，我们也要会使用它： 第1步： 打开Android Studio，点击Tools—&gt;Android—&gt;AVD Manager 。如图： 原生模拟器第1步 第2步： 点击Create a virtual device 。如图： 原生模拟器第2步 第3步： 选择要模拟的设备型号，例如Nexus 5 。如图： 原生模拟器第3步 第4步： 选择系统版本，如图： 原生模拟器第4步 第5步： 点击Show Advanced Setting，如图： 原生模拟器第5步 第6步： Virtual Device的优化设置，最后点击Finish。如图： 原生模拟器第6步 第7步： 回到了AVD Manager面板，出现了刚刚新建的Device，点击Actions中的绿色实心向右箭头运行该设备。如图： 原生模拟器第7步 第8步： 首次运行速度较慢，请耐心等待一会儿，Android 5.1就启动完毕。如图： 原生模拟器第8步 最快的模拟器原生的模拟器已经介绍完了，我们就先放下它了，毕竟我们在调试的时候讲究效率，所以，我们选择使用大名鼎鼎的的Genymotion。 Genymotion是一款速度很快的Android模拟器，原理是使用了Oracle的虚拟机Virtual Box来构建一个Android虚拟机。 从以下两个网站详细了解Genymotion的特性，并可以从中下载它。 Genymotion英文官网 Genymotion国人自建中文网 Genymotion下载要下载它需要先注册登录，这里 @安卓猴 给出一个百度网盘下载地址： Genymotion 2.5.3（带vbox）网盘下载， 密码：e1mf Genymotion安装安装就不多说了，直接一直Next就可以。 Genymotion使用第1步： 安装好后打开Genymotion进入主面板，点击Add添加新的虚拟器。如图： Genymotion第1步 第2步： 选择要虚拟的Android系统版本，并选择设备，这里选择Nexus5，点击Next后，会进入下载与配置界面，耐心等待；完成后回到Genymotion主界面。如图： Genymotion第2步 第3步： 在Genymotion的主面板中点击扳手小图标，设置刚刚建立的虚拟器，我们把它的内存设置为1024MB就够用。如图： Genymotion第3步 第4步： 在Genymotion的主面板中，选中虚拟器以后，点击Start启动它。如图： Genymotion第4步 第5步： 我们的Android5.1虚拟器就启动起来了！是不是很nice呀？试了一下，真的比原生模拟器 快 太多！如图： Genymotion第5步 下课相信看到这里， Android Studio 以及调试App所用的 史上最快虚拟器 都被我们玩懂了。 懂是懂了，可是还需深入学习，不是吗？ 有什么问题请在下面留言评论，我们一起进步！ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第2课之环境搭建","slug":"monkey-android-2","date":"2015-07-31T11:20:27.000Z","updated":"2016-05-13T20:07:42.000Z","comments":true,"path":"2015/07/31/monkey-android-2/","link":"","permalink":"http://sunjiajia.com/2015/07/31/monkey-android-2/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 通过本节课可以学习到的内容： Android开发环境的搭建 Android SDK及开发工具Android Studio的安装 SDK的下载和SDK目录详解 环境搭建安装JDK建议安装最新版JDK，下载链接，版本信息为： 123java version \"1.8.0_51\"Java(TM) SE Runtime Environment (build 1.8.0_51-b16)Java HotSpot(TM) 64-Bit Server VM (build 25.51-b03, mixed mode) 一路点击“下一步”，即可安装好JDK并配置好环境变量。 安装SDK在Google官方的下载页面，选择适合自己操作系统的版本进行下载。 这里提供一个Windows版本的百度网盘下载页面， 密码: v82w。 下载完成以后，请自己动手安装，建议安装在非系统盘。 安装过程不再赘述，这节我们重点看下SDK目录中各文件（夹）的作用。 了解SDKSDK，中文名字就是软件开发工具包，外语全称是Software Development Kit。 打开Android SDK Manager打开安装好的Android Studio，点击Configure，再点击SDK Manager: 打开SDK Manager SDK Manager界面 SDK下载在国内是无法直接下载SDK的各个组件的，原因想必你知我知大家知，我们不讨论。这里提供两种方法： 自备梯子 国内镜像 我们推荐使用国内镜像这种方法，步骤如下： 使用方法： 1.SDK Manager主界面，依次选择『Tools』、『Options…』，弹出『Android SDK Manager - Settings』窗口； 2.在『Android SDK Manager - Settings』窗口中，按照下面的示例图来设置； 3.依次选择『Packages』、『Reload』。 SDK Manager设置 下载内容现在的最新开发sdk是Android M，但还是预览版状态，因此，推荐下载Android 5.1.1(API 22)； 由于我们是个人（学习）开发，不着重考虑App在多个系统版本之间的兼容性，因此，我们推荐下载Android 4.2.2(API 17)； Android L是为了学习Materials Design带来的界面效果，Android 4.2.2是用来作对比用。 综上所述，这两个版本的SDK已经能够满足个人（学习）开发。 下面，看看我下载了哪些东西： Android 4.2.2(API 17)下载的东西 Extras中下载的东西 相信大家已经看到了，图中有些项目中显示着 Not installed ，有些是 Installed，具体原因如下： ARM EABI v7a System Image是Android系统在ARM架构上的系统镜像，这里由于我们是在Intel上，索性就不下载； 同理，MIPS System Image我们也不需要下载； Sources for Android SDK是一些Google给我们的源码，当我们需要了解某个功能为什么这么设计的时候，就需要读源码； Samples for SDK是一些Google给我们的示例，我们可以通过看Google大牛的程序来学习他们的写法。 Intel x86 Emulator Accelerator (HAXM installer)是一个让Android 虚拟器在intel下运行更快的组件，下载后在\\sdk\\extras\\intel\\Hardware_Accelerated_Execution_Manager目录下找到intelhaxm-android.exe安装就好； SDK目录结构详解add-ons文件夹： 这里面保存着附加库，比如GoogleMaps，当然你如果安装了OphoneSDK，这里也会有一些类库在里面。 docs文件夹： 这里面是Android SDK API参考文档，所有的API都可以在这里查到。 platforms文件夹： 是每个平台的SDK真正的文件，里面会根据APILevel划分的SDK版本，这里就以Android2.2来说，进入后有 一个android-8的文件夹，android-8进入后是Android2.2SDK的主要文件，其中ant为ant编译脚本，data保存着一些系 统资源，images是模拟器映像文件，skins则是Android模拟器的皮肤，templates是工程创建的默认模板，android.jar则 是该版本的主要framework文件，tools目录里面包含了重要的编译工具，比如aapt、aidl、逆向调试工具dexdump和编译脚本dx。 platform-tools文件夹： 保存着一些通用工具，比如adb、和aapt、aidl、dx等文件。 samples文件夹： 是Android SDK自带的默认示例工程，里面的apidemos强烈推荐初学者运行学习。 tools文件夹： 作为SDK根目录下的tools文件夹，这里包含了重要的工具，比如ddms用于启动Android调试工具，比如logcat、屏幕截图和文件管理器，而draw9patch则是绘制android平台的可缩放png图片的工具，sqlite3可以在PC上操作SQLite数据库， 而monkeyrunner则是一个不错的压力测试应用，模拟用户随机按键，mksdcard则是模拟器SD映像的创建工具，emulator是 Android SDK模拟器主程序，需要输入合适的参数才能启动模拟器，traceview作为android平台上重要的调试工具。 sources文件夹： 里面是不同版本Android的部分源代码； 下课相信看到这里，都对Android的开发环境和SDK有了初步的了解，下节课，我们将学习Android开发利器 Android Studio 的一般用法，以及调试App所用的 史上最快虚拟器 的用法。 有什么问题请在下面留言评论，我们一起进步！ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Android》第1课之前言","slug":"monkey-android-1","date":"2015-07-31T06:20:27.000Z","updated":"2016-05-13T20:07:50.000Z","comments":true,"path":"2015/07/31/monkey-android-1/","link":"","permalink":"http://sunjiajia.com/2015/07/31/monkey-android-1/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 前言《Monkey Java》刚刚撸完，立刻就开始撸《Monkey Android》系列了。 目标群体： Android新手 课程起点： 基于最新的Android 5.1.1 来学习；我们用最有效率的开发工具Android Studio。 知识储备： 学完《Monkey Java》系列 或者 有Java基础 修炼境界： 初级阶段；能写出简单界面的App，并能加入广告SDK上传市场赚取广告费；对Android环境有了解，根据自己的规划进一步深入学习。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Android》","slug":"《Monkey-Android》","permalink":"http://sunjiajia.com/categories/《Monkey-Android》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程10.0之结束篇","slug":"monkey-java-basic-courses-10-0","date":"2015-07-29T07:20:27.000Z","updated":"2016-05-13T20:07:54.000Z","comments":true,"path":"2015/07/29/monkey-java-basic-courses-10-0/","link":"","permalink":"http://sunjiajia.com/2015/07/29/monkey-java-basic-courses-10-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 结语到今天，《Monkey Java》系列的知识点都写完了，从头到尾都遵循着“入门”的准则，没有任何深奥的东西，几乎全部篇章都是在例子和注释中讲解知识点。在学习编程的过程中，如果不动手，那绝对就OUT了。 另外，《Monkey Java》中的Java知识绝对是不够用，它的目的在于为学习Android编程铺路。 接下来，我们会一直将《Monkey Android》系列走起，直到我们能写出一个自己的Android App。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程9.1之类集框架二","slug":"monkey-java-basic-courses-9-2","date":"2015-07-27T07:20:27.000Z","updated":"2016-05-13T20:08:00.000Z","comments":true,"path":"2015/07/27/monkey-java-basic-courses-9-2/","link":"","permalink":"http://sunjiajia.com/2015/07/27/monkey-java-basic-courses-9-2/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： Collection和Iterator接口 Set和HashSet的使用方法 Map和HashMap的使用方法 Collection和Iterator接口关系： Iterator &lt;– Collection &lt;– Set &lt;– HashSetIterator &lt;– Collection &lt;– List &lt;– ArrayList Collection接口方法： boolean add(Object o) 向集合中加入一个对象void clear() 删除集合当中的所有对象boolean isEmpty() 判断集合是否为空remove(Object o)从集合中删除一个对象的引用int size() 返回集合中元素的数目 Iterator接口方法： hsaNext()next() Set和HashSet的使用方法例子1：新建一个名为Demo01.java的源文件： 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.HashSet;import java.util.Iterator;import java.util.Set;public class Demo01 &#123; public static void main(String[] args) &#123; // Set中不允许有重复元素，如果有重复元素，直接忽略 Set&lt;String&gt; set = new HashSet&lt;String&gt;(); set.add(\"a\"); set.add(\"b\"); set.add(\"c\"); set.add(\"c\"); set.add(\"d\"); System.out.println(set.size()); set.remove(\"a\"); System.out.println(set.size()); set.clear(); System.out.println(set.size()); set.add(\"f\"); set.add(\"g\"); set.add(\"h\"); set.add(\"i\"); set.add(\"j\"); System.out.println(set.isEmpty()); // 生成一个迭代器对象，用于遍历整个Set Iterator&lt;String&gt; it = set.iterator(); while(it.hasNext()) &#123; String s = it.next(); System.out.println(s); &#125; &#125;&#125; Map和HashMap的使用方法例子2：新建一个名为Demo02.java的源文件： 123456789101112131415161718192021222324import java.util.HashMap;import java.util.Map;public class Demo02 &#123; public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put(\"1\", \"a\"); map.put(\"2\", \"b\"); map.put(\"3\", \"c\"); map.put(\"4\", \"d\"); // 如果放进去的键值对的键是存在的，那么后面放入的这个将会覆盖前面的值 map.put(\"3\", \"e\"); System.out.println(map.size()); String s = map.get(\"3\"); System.out.println(s); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程8.0之线程","slug":"monkey-java-basic-courses-8-0","date":"2015-07-26T14:20:27.000Z","updated":"2016-05-13T20:08:16.000Z","comments":true,"path":"2015/07/26/monkey-java-basic-courses-8-0/","link":"","permalink":"http://sunjiajia.com/2015/07/26/monkey-java-basic-courses-8-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 进程和线程的关系 多线程程序运行模式 定义线程的方法 控制线程的常用函数 多线程的数据安全 同步线程的方法 深入synchronized关键字 进程和线程的关系多进程： 在操作系统中能（同时）运行多个任务（程序）。 多线程： 在同一个应用程序中有多个顺序流（同时）进行。 多线程程序运行模式线程的执行过程： 图8—0—01。线程执行过程 定义线程的方法方法1： 定义一个线程类，它继承类Thread并重写其中的方法run()，方法run()称为线程体； 方法2： 提供一个实现接口Runnable的类作为线程的目标对象，在初始化一个Thread类或者Thread子类的线程对象时，把目标对象传递给这个线程实例，由该目标对象提供线程体。 例子1：1.新建一个FirstThread.java的源文件： 12345678class FirstThread extends Thread &#123; public void run()&#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"FirstThread--&gt;\" + i); &#125; &#125;&#125; 2.新建一个Demo01.java的源文件： 12345678910111213class Demo01 &#123; public static void main(String[] args) &#123; // 生成线程类的对象 FirstThread thread01 = new FirstThread(); // 启动线程 thread01.start(); for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"main--&gt;\" + i); &#125; &#125;&#125; 3.新建一个RunnableImpl.java的源文件： 12345678class RunnableImpl implements Runnable &#123; public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; System.out.println(\"Runnable--&gt;\" + i); &#125; &#125;&#125; 4.新建一个Demo02.java的源文件： 123456789101112131415161718class Demo02 &#123; public static void main(String[] args) &#123; // 生成一个Runnable接口实现类的对象 RunnableImpl ri = new RunnableImpl(); // 生成一个Thread对象，并将Runnable接口实现类的对象作为参数传递进去 Thread t = new Threadj(ri); t.start(); // 打印当前线程的优先级 // 默认优先级是5，最大优先级是10，最小优先级是1。 // 线程的优先级越高，它执行的概率就越大。 System.out.println(t.getPriority()); t.setPriority(Thread.MAX_PRIORITY); &#125;&#125; 控制线程的常用函数中断线程： Thread.sleep(2000);线程睡眠2000毫秒。Thread.yield();线程自动让出cpu。 设置线程的优先级： getPriority();setPriority(); 多线程的数据安全同步线程的方法 多线程共用同一份数据的时候，会出现某种错误； 因此需要在同步线程。 例子2：1.新建一个MyThread.java的源文件： 123456789101112131415161718class MyThread implements Runnable &#123; int i = 100; public void run()&#123; while (true) &#123; // 同步代码块 // 解决多线程共用同一份数据时出现错误的问题 synchronized (this) &#123; System.out.println(Thread.currentThread().getName() + i); i--; Thread.yield(); if (i &lt; 0) &#123; break; &#125; &#125; &#125; &#125;&#125; 2.新建一个Demo03.java的源文件： 123456789101112131415161718class Demo03 &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); // 生成两个Thread对象，但是这两个对象共用同一个线程体 Thread t1 = new Thread(myThread); Thread t2 = new Thread(myThread); // 每一个线程都有名字，可以通过Thread对象的setName()方法设置 t1.setName(\"线程a\"); t2.setName(\"线程b\"); // 分别启动两个线程 t1.start(); t2.start(); &#125;&#125; 深入synchronized关键字 同步锁，它锁住的是对象。如果一个线程获得了一个对象的同步锁，那么这个对象上面的所有的其它的同步代码都是不能够被其它线程执行的，都需要等待同步锁被释放后，才能够进行。 例子3：1.新建一个名为Service.java的源文件： 123456789101112131415161718class Service &#123; public voi fun1 () &#123; synchronized (this) &#123; try &#123; Thread.sleep(3000); &#125; catch (Exception e) &#123; System.out.println(e); &#125; System.out.println(\"fun1\"); &#125; &#125; // fun2是一个同步方法，和fun1中的同步代码块功能一样 public synchronized voi fun2 () &#123; System.out.println(\"fun2\"); &#125;&#125; 2.新建一个名为MyThread1.java的源文件： 12345678910111213class MyThread1 implements Runnable &#123; private Service service; public MyThread1 (Service service) &#123; this.service = service; &#125; public void run () &#123; service.fun1(); &#125;&#125; 3.新建一个名为MyThread2.java的源文件： 12345678910111213class MyThread2 implements Runnable &#123; private Service service; public MyThread2 (Service service) &#123; this.service = service; &#125; public void run () &#123; service.fun2(); &#125;&#125; 4.新建一个名为Demo04.java的源文件： 123456789101112class Demo04 &#123; public static void main(String[] args) &#123; Service service = new Service(); Thread t1 = new Thread(new MyThread1(service)); Thread t2 = new Thread(new MyThread2(service)); t1.start(); t2.start(); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程9.1之类集框架一","slug":"monkey-java-basic-courses-9-1","date":"2015-07-26T14:20:27.000Z","updated":"2016-05-13T20:08:06.000Z","comments":true,"path":"2015/07/26/monkey-java-basic-courses-9-1/","link":"","permalink":"http://sunjiajia.com/2015/07/26/monkey-java-basic-courses-9-1/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 类集框架 集合的种类 类集框架的基础结构 类集框架 类集框架是一组类和接口 位于java.util包当中 主要用于存储和管理对象 主要分为三大类：集合、列表和映射 集合： 集合中的对象不按特定的方式排序，并且没有重复对象； 列表： 集合中的对象按照索引位置排序，可以有重复的对象。 映射： 集合中每一个元素包含一个键对象和一个值对象，键不可以重复，值可以重复。 类集框架的基础结构 图9-0。01类集框架结构 例子1：1.新建一个名为Demo01.java的源文件： 1234567891011121314151617181920212223242526import java.util.ArrayList;public class Demo6 &#123; public static void main(String[] args) &#123; // 它的长度是无限延伸的 // String是泛型，也可以为其它类型，规定了此ArrayList中只能存放String类型的元素 ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(); arrayList.add(\"A\"); arrayList.add(\"AA\"); arrayList.add(\"AAA\"); arrayList.add(\"AAAA\"); System.out.println(arrayList.get(2)); for (int i = 0; i &lt; arrayList.size(); i++) &#123; System.out.println(arrayList.get(i)); &#125; // 移除一个元素 arrayList.remove(0); System.out.println(arrayList.size()); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程9.0之数组","slug":"monkey-java-basic-courses-9-0","date":"2015-07-26T01:20:27.000Z","updated":"2016-05-13T20:08:10.000Z","comments":true,"path":"2015/07/26/monkey-java-basic-courses-9-0/","link":"","permalink":"http://sunjiajia.com/2015/07/26/monkey-java-basic-courses-9-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 数组的类型 数组的定义方法 数组的操作方法 数组的类型数组的定义方法数组的操作方法例子1：1234567891011121314151617181920212223242526272829303132class Demo01 &#123; public static void main(String[] args) &#123; // 数组的静态定义法 // arr是一个整型数组 int[] arr = &#123; 2, 5, 6, 7, 8, 4, 0 &#125;; // 取数组中的一个值：arr[下标]，下标从0开始。 System.out.println(arr[3]); // 打印数组中所有的元素 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125; // 数组的动态声明法，10表示数组的长度为10 // arr2中的元素的值默认为0 int[] arr2 = new int [10]; // 二维数组的定义方法 int[][] arr3 = &#123;&#123; 1, 5, 6&#125;, &#123; 5, 8, 9&#125;, &#123; 2, 5&#125;&#125;; System.out.println(arr[1][1]); for (int i = 0; i &lt; arr3.length; i++) &#123; for (int j = 0; j &lt; arr3[i].length; j++) &#123; System.out.println(arr[i][j]); &#125; &#125; &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程7.2之内部类和匿名内部类","slug":"monkey-java-basic-courses-7-2","date":"2015-07-26T01:20:27.000Z","updated":"2016-05-13T20:08:20.000Z","comments":true,"path":"2015/07/26/monkey-java-basic-courses-7-2/","link":"","permalink":"http://sunjiajia.com/2015/07/26/monkey-java-basic-courses-7-2/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 什么是内部类 内部类的使用方法 匿名内部类的使用方法 什么是内部类含义： 一个类定义在另一个类内部。 例子1：1.新建一个名为A.java的源文件： 1234567891011121314class A &#123; int i; // B类就是内部类 class B &#123; int j; int funB()&#123; // 内部类B可以使用外部类A的成员变量和成员方法 int result = i + j; return result; &#125; &#125;&#125; 注意： 在编译A.java源文件后，会生成两个class文件，即A.class和A$B.class。 内部类的使用方法 要生成一个内部类对象，首先要有一个外部类对象。 例子2：1.新建一个名为Demo01.java的源文件： 1234567891011121314151617class Demo01 &#123; public static void main(String[] args) &#123; // 生成外部类的对象 A a = new A(); // 生成内部类的对象 A.B b = new A().new B(); a.i= 3; b.j = 1; int result = b.funB(); System.out.println(result); &#125;&#125; 匿名内部类 首先是一个内部类 其次它没有名字 例子3：1.新建一个名为C.java的源文件： 1234interface C &#123; public void doSomething();&#125; 2.新建一个名为D.java的源文件： 123456class D &#123; public void fun(C c)&#123; System.out.println(\"D类的fun函数\"); c.doSomething(); &#125;&#125; 3.新建一个名为Demo02.java的源文件： 123456789101112class Demo02 &#123; public static void main(String[] args) &#123; D d = new D(); // fun括号中就是匿名内部类 d.fun(new C()&#123; public void doSomething() &#123; System.out.println(\"匿名内部类\"); &#125; &#125;); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程7.1之IO","slug":"monkey-java-basic-courses-7-1","date":"2015-07-21T01:20:27.000Z","updated":"2016-05-13T20:08:24.000Z","comments":true,"path":"2015/07/21/monkey-java-basic-courses-7-1/","link":"","permalink":"http://sunjiajia.com/2015/07/21/monkey-java-basic-courses-7-1/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： IO操作的目标 IO的分类方法 读取文件和写入文件的方法 大文件的读写方法 字符流的使用方法 处理流的使用实例 “装饰者（Decorator）”模式 节点流与处理流的关系 IO操作的目标 从数据源当中读取数据，以及将数据写入到数据的目的地当中。 特点： I/O系统的主要目标是为了对数据进行读写操作； 数据的流向以Java程序为参照物； I/O流可以有三种分类方法； 有read和write两个主要方法。 IO的分类方法第一种： 输入流；输出流。 第二种： 字节流；字符流。 第三种： 节点流；处理流。 特点： BufferedReader：字符输入处理流；readline()方法，每次读取一行，返回一个字符串； BufferedReader br = new BufferedReader(new FileReader(“xxx.txt”)); 读取文件和写入文件的方法核心类 InputStream和FileInputStream（从硬盘中文件读取数据） OutputStream和FileOutputStream（把数据写入硬盘中文件） 例子1：（请动手）1.新建txt文件分别名为from.txt和to.txt；在from.txt中写上字符串abcd，然后新建一个名为Demo01.java的源文件： 123456789101112131415161718192021222324// 1.导入类；import java.io.*;class Demo01 &#123; public static void main(String[] args) &#123; // 2.声明输入流引用、生成输出流的引用 FileInputStream fis = null; FileOutputStream fos = null; try &#123; // 3.生成代表输入流的对象、生成代表输出流的对象 fis = new FileInputStream(\"e:/src/from.txt\"); fos = new FileOutputStream(\"e:/src/to.txt\"); // 4.生成一个字节数组 byte[] buffer = new byte[100]; // 5.调用输入流对象的read方法，读取数据;调用输出流对象的write方法，写入数据; int temp = fis.read(buffer, 0, buffer.length); fos.write(buffer, 0, temp); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 大文件的读写方法例子2：（请动手）1.新建txt文件分别名为from2.txt和to2.txt；在from2.txt中写上一篇很长（几万字，网上copy）的纯英文文章，然后新建一个名为Demo02.java的源文件： 123456789101112131415161718192021222324252627282930313233343536373839import java.io.*;class Demo02 &#123; public static void main(String[] args) &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(\"e:/src/from2.txt\"); fos = new FileOutputStream(\"e:/src/to2.txt\"); byte[] buffer = new byte[1024]; while (true) &#123; int temp = fis.read(buffer, 0, buffer.length); // temp是-1的时候，说明read函数已经读完 // 这时跳出循环 if (temp == -1) &#123; break; &#125; fos.write(buffer, 0, temp); &#125; &#125; catch (Exception e) &#123; System.out.println(e); &#125; finally &#123; try &#123; // 一定要执行输入输出流的关闭 fis.close(); fos.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; &#125;&#125; 字符流的使用方法 读写文件时，以字符为基础； 字节输入流（常用FileReader）都是Reader的子类； 字节输出流（常用FileWriter）都是Writer的子类。 例子3：（请动手） 使用前面的from.txt和to.txt来进行操作。 1234567891011121314151617181920212223242526272829303132import java.io.*;class Demo03 &#123; public static void main(String[] args) &#123; FileReader fr = null; FileWriter fw = null; try &#123; fr = new FileReader(\"e:/src/from.txt\"); fw = new FileWriter(\"e:/src/to.txt\"); char[] buffer = new char[100]; int temp = fr.read(buffer, 0, buffer.length); fw.write(buffer, 0, temp); &#125; catch (Exception e) &#123; System.out.println(e); &#125; finally &#123; try &#123; fr.close(); fw.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; &#125;&#125; 处理流的使用实例例子4：BufferedReader的使用 1234567891011121314151617181920212223242526272829303132333435import java.io.*;class Demo04 &#123; public static void main(String[] args) &#123; FileReader fr = null; BufferedReader br = null; try &#123; fr = new FileReader(\"e:/src/from.txt\"); br = new BufferedReader(fr); String line = null; while (true) &#123; line = br.readLine(); if (line == null) &#123; break; &#125; System.out.println(line); &#125; &#125; catch (Exception e) &#123; System.out.println(e); &#125; finally &#123; try &#123; fr.close(); br.close(); &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; &#125;&#125; “装饰者（Decorator）”模式例子5：1.定义一个Worker接口 123interface Worker &#123; public void doSomeWork();&#125; 2.定义一个A公司的类AWorker，文件名为AWorker.java： 12345678910111213class AWorker implements Worker &#123; private Worker worker; public AWorker (Worker worker) &#123; this.worker = worker; &#125; public void doSomeWork() &#123; System.out.println(\"你好。我是A公司\"); worker.doSomeWork(); &#125;&#125; 3.新建两个文件名为Plumber.java和Carpenter.java的源文件： 12345class Plumber implements Worker &#123; public void doSomeWork() &#123; System.out.println(\"修水管\"); &#125;&#125; 12345class Carpenter implements Worker &#123; public void doSomeWork() &#123; System.out.println(\"修门窗\"); &#125;&#125; 4.新建一个名为Demo05.java的Java源文件： 1234567891011121314class Demo05 &#123; public static void main(String[] args) &#123; // 生成一个A公司水管工对象 Plumber plumber = new Plumber(); AWorker aWorker1 = new AWorker(plumber); aWorker1.doSomeWork(); Carpenter carpenter = new Carpenter(); AWorker aWorker2 = new AWorker(carpenter); aWorker2.doSomeWork(); &#125;&#125; 节点流与处理流的关系 处理流就是用来处理节点流的，增加节点流的功能。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程7.0之Java当中的异常","slug":"monkey-java-basic-courses-7-0","date":"2015-07-19T23:20:27.000Z","updated":"2016-05-13T20:08:28.000Z","comments":true,"path":"2015/07/20/monkey-java-basic-courses-7-0/","link":"","permalink":"http://sunjiajia.com/2015/07/20/monkey-java-basic-courses-7-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 什么是异常 异常的分类 try…catch…finally结构的使用方法 throw的作用 throws的作用 什么是异常含义： 在面向对象的世界中，异常也是对象； 我们自己的话说，Java程序在正常运行中，出现的一些意外，被称为异常。 定义：中断了正常指令流的事件； 异常和语法错误是不同的东西； 语法错误在编译的时候就会报错；而异常是在运行的时候抛出来的。 格式: 12Exception in thread \"main\" java.lang.ArithmeticException: / by zero at Demo5.main(Demo.java:3) 例子1:这个例子它报上面格式中的错误。 12345class Demo&#123; public static void main(String[] args) &#123; int i = 1 / 0; &#125;&#125; 异常的分类 所有的异常都是Throwable的直接子类； 有2个这样的类Exception和Error； Error是JVM在运行是产生的错误，一旦产生它，JVM就会直接关闭； Error也有各种子类； Exception就是我们学习的异常，它也有很多子类，我们将在开发中遇到； Exception分为两大类：运行时异常和编译时异常; 异常被捕捉后，程序可以正常运行和编译。 try…catch…finally结构的使用方法格式： 1234567891011121314try &#123; // 有可能出现异常的代码，如果语句2出现异常，那么其后面的语句不再执行， // 直接跳入catch体。 语句1； 语句2； ...&#125; catch(Exception e) &#123; // Exception e是JVM产生的异常对象； // 在这里捕捉异常； e.printStackTrace(); //打印异常信息；&#125; finally &#123; // 无论是否捕捉到了异常，都会执行。有时也称为异常的出口 语句；&#125; 例子2：（请动手）1234567891011121314class Demo&#123; public static void main(String[] args) &#123; try &#123; System.out.println(\"Hello Monkey!\"); // 有可能出现异常的代码 int i = 1 / 0; &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 无论是否捕捉到了异常，都会执行。有时也称为异常的出口 System.out.println(\"Hello Android!\"); &#125; &#125;&#125; throw和throws例子3：（请动手）1.新建一个User.java的源文件： 1234567891011121314151617181920class User &#123; private int age; private int money; public void setAge(int age) &#123; if (age &lt; 0) &#123; // 生成一个异常对象 RuntimeException e = new RuntimeException(\"年龄不能为负数！\"); // 抛出这个异常 throw e; &#125; this.age = age; &#125; // throws的用法，对象在使用这个函数时，必须要捕捉异常。 public void setMoney(int money) throws Exception &#123; this.money = money; &#125;&#125; 2.新建一个Demo01.java的源文件： 1234567891011121314151617class Demo01 &#123; public static void main(String[] args) &#123; User user01 = new User(); //年龄怎么会有负数呢？因此我们要捕捉这个异常。 user01.setAge(-20); try &#123; user01.setMoney(2000); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println(\"2000太少！\"); &#125; &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程6.4之接口的基本语法与应用（重要）","slug":"monkey-java-basic-courses-6-4","date":"2015-07-18T03:20:27.000Z","updated":"2016-05-13T20:08:32.000Z","comments":true,"path":"2015/07/18/monkey-java-basic-courses-6-4/","link":"","permalink":"http://sunjiajia.com/2015/07/18/monkey-java-basic-courses-6-4/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 什么是接口 接口的基本语法 为什么要使用接口 工厂方法模式 什么是接口含义： Java接口是一系列方法的声明，一个接口只有方法的特征没有方法的实现，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）。 接口的基本语法 使用interface定义； 接口当中的方法都是抽象方法（不用写abstract）； 接口当中的方法都是public权限（不用写public）； 实现接口使用implements关键字； 一个类可以实现多个接口； 一个接口可以继承多个接口； 注意： 不能生成对象； 用一个类来实现（关键字是implements）接口使用它； 复写接口中的抽象方法实现相应的功能。 例子1：（请动手）1.新建一个名为USB.java的源文件： 12345interface USB&#123; // 它们是public权限的抽象函数 void read(); void write();&#125; 2.新建一个名为WIFI.java的源文件： 12345interface WIFI&#123; // 它们是public权限的抽象函数 void open(); void close();&#125; 3.新建一个名为USBPhone.java的源文件： 1234567891011121314151617class USBPhone implements USB,WIFI&#123; void read()&#123; System.out.println(\"USBPhone read!\"); &#125; void write()&#123; System.out.println(\"USBPhone write!\"); &#125; void open()&#123; System.out.println(\"WIFI open!\"); &#125; void open()&#123; System.out.println(\"WIFI close!\"); &#125;&#125; 4.新建一个名为Demo01.java的源文件： 12345678910111213141516class Demo01&#123; public static void main(String[] args) &#123; USBPhone phone = new USBPhone(); // 向上转型 USB usb = phone; WIFI wifi = phone; usb.read(); usb.write(); wifi.open(); wifi.close(); &#125;&#125; 为什么要使用接口工厂方法模式 请反复练习下面的例子2，在代码中深刻理解为什么要使用接口和工厂方法模式。 关于工厂方法模式的定义，请阅读百度百科词条【工厂方法模式】。 例子2：（请动手）1.新建一个名为Printer.java的源文件： 12345interface Printer&#123; void open(); void close(); void print(String s);&#125; 2.新建一个名为HPPrinter.java的源文件： 1234567891011class HPPrinter implements Printer&#123; void open()&#123; System.out.println(\"HP open\"); &#125; void close()&#123; System.out.println(\"HP close\"); &#125; void print(String s)&#123; System.out.println(\"HP print--&gt;\" + s); &#125;&#125; 3.新建一个名为CanonPrinter.java的源文件： 1234567891011121314class CanonPrinter implements Printer&#123; private void clean()&#123; System.out.println(\"Canon clean\"); &#125; void open()&#123; System.out.println(\"Canon open\"); &#125; void close()&#123; System.out.println(\"Canon close\"); &#125; void print(String s)&#123; System.out.println(\"Canon print--&gt;\" + s); &#125;&#125; 4.新建一个名为Demo02.java的源文件： 1234567891011121314151617class Demo02&#123; public static void main(String[] args) &#123; Printer printer = null; // 用flag来模拟用户选择打印机。 int flag = 0; if (flag == 0) &#123; printer = new HPPrinter(); &#125; else if (flag == 1) &#123; printer = new CanonPrinter(); &#125; printer.open(); printer.print(\"abcdefghijklmn\"); printer.close(); &#125;&#125; 5.新建一个名为PrinterFactory.java的源文件： 123456789101112class PrinterFactory&#123; public static Printer getPrinter(int flag)&#123; Printer printer = null; // 用flag来模拟用户选择打印机。 if (flag == 0) &#123; printer = new HPPrinter(); &#125; else if (flag == 1) &#123; printer = new CanonPrinter(); &#125; return printer; &#125;&#125; 6.新建一个名为Demo03.java的源文件： 123456789class Demo03&#123; public static void main(String[] args) &#123; int flag = 0; Printer printer = PrinterFactory.getPrinter(flag); printer.open(); printer.print(\"abcdefghijklmn\"); printer.close(); &#125;&#125; 请注意4、5、6不同写法的意义。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程6.3之protected权限","slug":"monkey-java-basic-courses-6-3","date":"2015-07-16T12:30:27.000Z","updated":"2016-05-13T20:08:34.000Z","comments":true,"path":"2015/07/16/monkey-java-basic-courses-6-3/","link":"","permalink":"http://sunjiajia.com/2015/07/16/monkey-java-basic-courses-6-3/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： protected权限 protected权限 protected权限首先拥有和default一样的功能； 但是它只能修饰成员变量和成员函数； 允许跨软件包的继承； 只允许类的子类继承使用它的protected成员属性和函数； 例子：（请动手）1、新建一个Person.java源文件： 1234567891011121314package com.sunjiajia;public class Person&#123; protected String name; protected int age; void eat()&#123; System.out.println(\"eat\"); &#125; void sleep()&#123; System.out.println(\"sleep\"); &#125;&#125; 2、新建一个Student.java源文件： 12345678910package org.sunjiajia;import com.sunjiajia.*;class Student extends Person&#123; void introduce()&#123; System.out.println(\"我的名字是 \" + name + \"，我的年龄是 \" + age); &#125;&#125; 权限的总结 public &gt; protected &gt; default &gt; private 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程6.2之访问权限","slug":"monkey-java-basic-courses-6-2","date":"2015-07-16T07:30:27.000Z","updated":"2016-05-13T20:08:38.000Z","comments":true,"path":"2015/07/16/monkey-java-basic-courses-6-2/","link":"","permalink":"http://sunjiajia.com/2015/07/16/monkey-java-basic-courses-6-2/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： Java当中的访问权限 软件包的导入 Java当中的访问权限一共分为4大类： public：公共权限，既可以修饰类，也可以修饰成员变量和成员函数； private：私有权限 default：包级别访问权限 protected：受保护权限 public权限 如果一个类不是public（公共）的，那么这个类不能被外部软件包访问； 如果一个类的成员变量或者方法不是public（公共）的，那么它们也不能被外部软件包访问； 没有任何限制，同一个包中，或者不同软件包当中，都可以只有访问。 private权限 一般情况下只能修饰成员变量和成员函数； 如果成员变量或者函数被private修饰，那么它们只能在本类中被访问。 default权限 默认权限，如果类、成员变量或者成员方法没有被任何其它权限修饰，那么它就是default权限； 如果两个类在同一软件包中，那么可以自由使用彼此的成员方法和函数。 protected权限（重要）这部分内容下节课再讲。 软件包的导入 导入其他软件包的类，方便代码的书写。 格式： 1import com.sunjiajia.Person; 如果软件包下面有多个要使用的类，那么可以一次导入该包下面的所有类： 1import com.sunjiajia.*; 例子：（请动手）1.新建一个名为Person.java的Java源文件： 12345678910111213package com.sunjiajiapublic class Person&#123; public String name; public int age; private int grade; public void introduce()&#123; System.out.println(name); &#125;&#125; 2.新建一个名为Demo01.java的Java源文件： 12345678910111213package sunjiajia.demo;import com.sunjiajia.Person;public class Demo01&#123; com.sunjiajia.Person p = new com.sunjiajia.Person(); p.name = 'li4'; p.age = 18; // 下面这行代码会报错，参见private的用法； // p.grade = 5; p.introduce();&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程6.1之包（package）","slug":"monkey-java-basic-courses-6-1","date":"2015-07-16T05:30:27.000Z","updated":"2016-05-13T20:09:00.000Z","comments":true,"path":"2015/07/16/monkey-java-basic-courses-6-1/","link":"","permalink":"http://sunjiajia.com/2015/07/16/monkey-java-basic-courses-6-1/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 什么是Java当中的软件包 为什么要使用软件包 如何给一个类打包 什么是Java当中的软件包简单的理解，就是将编译后的.class文件放在不同的文件夹下面。 软件包为Java类提供了命名空间； 打包需要使用package指令； 一个类的全名应该是“包名.类名”。 格式： 1package com.sunjiajia.demo; 示例：（请动手） 1、 新建Demo01.java文件： 1234567package androidmonkey.demo;class Demo01&#123; public static void main(String[] args) &#123; System.out.println(\"hello demo01\"); &#125;&#125; 2、 新建 Demo02.java文件： 1234567package androidmonkey.demo;class Demo02&#123; public static void main(String[] args) &#123; System.out.println(\"hello demo02\"); &#125;&#125; 为什么要使用软件包 使用软件包可以将不同功能的类分别开来，方便代码的维护与更新，符合面向对象的编程思想。 使用软件包以后，一个类的全名应该是 包名.类名。 如何给一个类打包编译方法编译Java源文件的时候需要用这个命令： 1javac -d . *.java 注意： .表示在当前文件夹下进行编译； *.java表示当前文件夹下的所有java源文件都编译； -d表示依照包名生成相应的文件夹。 执行方法执行.class文件时需要用类的全称： 1java androidmonkey.demo.Demo01 包名的命名规范： 要求包名的所有的字母都要小写； 包名一般情况下是域名段倒过来写（com.sunjiajia）； 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程6.0之抽象类和抽象函数","slug":"monkey-java-basic-courses-6-0","date":"2015-07-16T02:30:27.000Z","updated":"2016-05-13T20:09:12.000Z","comments":true,"path":"2015/07/16/monkey-java-basic-courses-6-0/","link":"","permalink":"http://sunjiajia.com/2015/07/16/monkey-java-basic-courses-6-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 抽象函数的语法特征 抽象类的语法特征 抽象类的作用 抽象函数的语法特征定义： 只有函数的定义（返回值类型、函数名、参数列表），没有函数体的函数被称为抽象函数。 特点： 如果一个类中有一个或者一个以上的抽象函数，那么这个类也必须被定义为抽象类； 格式：1abstract void function(); 抽象类的语法特征定义： 使用abstract定义的类（在class前加上abstract关键字）称之为抽象类。 特点： 抽象类天生就是用来被继承的，俗称基类；抽象类的子类也必须声明为抽象的，或者，必须在子类中复写父类中的抽象函数； 抽象类不能够生成对象；但抽象类可以有构造函数，它可以在子类中被调用；（重要） 如果一个类当中包含有抽象函数，那么这个类必须被声明为抽象函数； 如果一个类当中没有抽象函数，那么这个类也可以被声明为抽象类。 例子1：（请动手） 创建一个名为Person.java的Java源文件： 123456789101112131415161718192021abstract class Person&#123; String name; int age; Person()&#123; System.out.println(\"Person的构造函数\"); &#125; Person(String name, int age)&#123; this.name = name; this.age = age; System.out.println(\"Person的2个参数构造函数\"); &#125; void introduce()&#123; System.out.println(\"我的名字叫 \" + this.name + \"，我的年龄是 \" + this.age); &#125; //抽象函数 abstract void eat();&#125; 2.创建一个名为Chinese.java的Java源文件：1234567891011121314151617181920class Chinese extends Person &#123; String address; Chinese()&#123; System.out.println(\"Chinese的构造函数\"); &#125; Chinese(String name, int age, String address)&#123; super(name, age); this.address = address; System.out.println(\"Chinese的3个参数构造函数\"); &#125; // Chinese这个子类复写了Person中的抽象函数eat()， // 复写后的eat()函数不再是抽象函数， // 因此，Chinese类中没有抽象函数，它也不需要声明为抽象类。 void eat()&#123; System.out.println(\"用筷子吃饭！\"); &#125;&#125; 3.创建一个名为Demo01.java的Java源文件：1234567class Demo01 &#123; public static void main(String[] args) &#123; // 子类的对象赋值给父类的引用，这是向上转型。 Person p01 = new Chinese(); p01.eat(); &#125;&#125; 抽象类的作用作用： 父类无法完成的函数具体功能，就声明为抽象函数，让子类复写实现（必须）； 通过方法的复写实现了多态的属性。 例子2：（请动手） 1.新建一个Printer.java的Java源文件： 12345678910abstract class Printer&#123; void open()&#123; System.out.println(\"open\"); &#125; void close()&#123; System.out.println(\"close\"); &#125; // 抽象函数print() abstract void print();&#125; 2.新建一个HpPrinter.java的Java源文件： 1234567// 该惠普打印机为喷墨打印机class HpPrinter extends Printer&#123; // 重写父类的抽象方法print()方法 void print()&#123; System.out.println(\"使用惠普喷墨打印机进行打印\"); &#125;&#125; 3.新建一个CanonPrinter.java的Java源文件： 1234567// 该佳能打印机为针式打印机class CanonPrinter extends Printer&#123; // 重写父类的抽象方法print()方法 void print()&#123; System.out.println(\"使用佳能针式打印机进行打印\"); &#125;&#125; 4.新建一个Demo01.java的Java源文件： 1234567891011121314// 该佳能打印机为针式打印机class Demo01&#123; public static void main(String[] args) &#123; Printer hp = new HpPrinter(); // 向上转型 hp.open(); hp.print(); hp.close(); Printer cannon = new CanonPrinter(); cannon.open(); cannon.print(); cannon.close(); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程5.6之面向对象应用","slug":"monkey-java-basic-courses-5-6","date":"2015-07-16T01:00:27.000Z","updated":"2016-05-13T20:09:16.000Z","comments":true,"path":"2015/07/16/monkey-java-basic-courses-5-6/","link":"","permalink":"http://sunjiajia.com/2015/07/16/monkey-java-basic-courses-5-6/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 被客户不断变化的需求所“折磨”； 客户第1次需求：我有一台惠普打印机，开发一个打印机控制程序，要能够实现开机、关机和打印功能； 客户第2次需求：我的办公室加了一台新的佳能打印机，把你的程序修改一下； 客户第3次需求：我的办公室又又加了一台新的清华同方打印机！（自己实现） 1.新建一个名为Printer.java的Java源文件：1234567891011class Printer&#123; void open()&#123; System.out.println(\"Open\"); &#125; void close()&#123; System.out.println(\"Close\"); &#125; void print(String s)&#123; System.out.println(\"print---&gt;\" + s); &#125;&#125; 2.新建一个名为HpPrinter.java的Java源文件：12class HpPrinter extends Printer&#123;&#125; 3.新建一个名为CanonPrinter.java的Java源文件：123456789class CanonPrinter extends Printer&#123; void close()&#123; this.clean(); super.close(); &#125; void clean()&#123; System.out.println(\"clean\"); &#125;&#125; 4.新建一个名为Demo.java的Java源文件：123456789101112131415161718class Demo&#123; public static void main(String[] args) &#123; // 用来判断选择惠普打印机还是佳能打印机 // 0代表惠普，1代表佳能 int flag = 0; if(flag == 0)&#123; HpPrinter hpPrinter = new HpPrinter(); hpPrinter.open(); hpPrinter.print(\"锄禾日当午\"); hpPrinter.close(); &#125; else if (flag == 1) &#123; CanonPrinter canonPrinter = new CanonPrinter(); canonPrinter.open(); canonPrinter.print(\"汗滴禾下土\"); canonPrinter.close(); &#125; &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程5.5之对象的转型","slug":"monkey-java-basic-courses-5-5","date":"2015-07-16T00:00:27.000Z","updated":"2016-05-13T20:09:20.000Z","comments":true,"path":"2015/07/16/monkey-java-basic-courses-5-5/","link":"","permalink":"http://sunjiajia.com/2015/07/16/monkey-java-basic-courses-5-5/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 对象的向上转型 对象的向下转型 对象的向上转型概念： 将子类的对象赋值给父类的引用。 注意： 两个类一定要有继承关系； 将子类的对象赋值给父类的引用； 一个引用能够调用哪些成员（变量、方法），取决于这个引用的类型； 一个引用调用的是哪个方法，取决于这个引用所指向的对象。 格式：12345// Student类是Person类的子类Student s = new Student();// 将子类的对象s赋值给父类的引用p；// 理解：每一个学生都是一个人。Person p = s; 例子1：（请动手）1.新建一个名为Person.java的Java源文件： 12345678class Person&#123; String name; int age; void introduce()&#123; System.out.println(\"我的名字叫 \" + this.name + \"，我的年龄是 \" + this.age); &#125;&#125; 2.新建一个名为Student.java的Java源文件： 123456789101112class Student extends Person&#123; int grade; void study()&#123; System.out.println(\"我正在学习。\"); &#125; void introduce()&#123; super.introduce(); System.out.println(\"我的年级是 \" + grade); &#125;&#125; 3.新建一个名为Demo01.java的Java源文件： 1234567891011121314151617class Demo01&#123; public static void main(String[] args) &#123; // 子类Student的对象stu01 Student stu01 = new Student(); // 向上转型 // 将子类的对象stu01赋值给父类的引用p1 Person p1 = stu01; p1.name = \"li4\"; p1.age = 18; // 这里的introduce()方法是子类的。 // 引用p1指向的对象是stu01，因此p1所调用的方法是stu01的方法。 p1.introduce(); &#125;&#125; 对象的向下转型概念： 将父类的对象赋值给子类的引用。 格式：12345Student stu01 = new Student();// 向上转型Person p1 = stu01;// 向下转型Student stu02 = (Student)p1; 特点： 要进行向下转型，先进性向上转型；* 例子2：（请动手）1.新建一个名为Demo01.java的Java源文件：1234567891011class Demo01&#123; public static void main(String[] args) &#123; // 子类Student的对象stu01 Student stu01 = new Student(); // 向上转型 Person p1 = stu01; // 向下转型 Student stu02 = (Student)p1; &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程5.4之函数的复写（override）","slug":"monkey-java-basic-courses-5-4","date":"2015-07-15T04:00:27.000Z","updated":"2016-05-13T20:09:24.000Z","comments":true,"path":"2015/07/15/monkey-java-basic-courses-5-4/","link":"","permalink":"http://sunjiajia.com/2015/07/15/monkey-java-basic-courses-5-4/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 函数的复写（override） 使用super调用父类的成员函数 函数的复写（override） 复写（override），也被称为覆盖或者重写。在你对父类的成员方法不满意的时候，你可以在子类中复写这个方法，来写出符合自己要求的方法。 特点： 1.在具有父子关系的两个类当中； 2.子类和父类中各有一个函数，这个函数的定义（返回值类型，函数名和参数列表）完全相同，那么它们的关系就是复写。 使用super调用父类的成员函数左右: 减少子类复写父类的成员方法时出现的重复代码。 例子：（请动手）1.新建一个名为Person.java的Java源文件： 12345678class Person&#123; String name; int age; void introduce()&#123; System.out.println(\"我的名字叫 \" + this.name + \"，我的年龄是 \" + this.age); &#125;&#125; 2.新建一个名为Student.java的Java源文件： 12345678910class Student extends Person&#123; int grade; // 复写（override），也被称为覆盖或者重写 void introduce()&#123; // 使用super调用父类Person的成员函数； // 它不一定必须写在第一行。 super.introduce(); System.out.println(\"我的年级是 \" + grade); &#125;&#125; 3.新建一个名为Demo01.java的Java源文件： 123456789101112131415class Demo01&#123; public static void main(String[] args) &#123; Student stu01 = new Student(); stu01.name = \"zhang3\"; stu01.age = 19; stu01.grade = 8; stu01.introduce(); Person p1 = new Person(); p1.name = \"zhang3\"; p1.age = 19; p1.introduce(); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程5.3之子类实例化","slug":"monkey-java-basic-courses-5-3","date":"2015-07-15T04:00:27.000Z","updated":"2016-05-13T20:09:28.000Z","comments":true,"path":"2015/07/15/monkey-java-basic-courses-5-3/","link":"","permalink":"http://sunjiajia.com/2015/07/15/monkey-java-basic-courses-5-3/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 生成子类的过程 使用super调用父类构造函数的方法 生成子类的过程使用super调用父类构造函数的方法注意： 在子类的构造函数中，必须调用父类的构造函数； super所调用的是父类的哪个构造函数，是由super(参数)中的参数个数决定； super(参数);必须是构造函数的第一行。 例子：（请动手） 1.新建一个名为Person.java的Java源文件： 123456789101112131415161718class Person&#123; String name; int age; Person()&#123; System.out.println(\"Person的无参数构造函数\"); &#125; Person(String name, int age)&#123; this.name = name; this.age = age; System.out.println(\"Person的有参数构造函数\"); &#125; void eat()&#123; System.out.println(\"吃东西\"); &#125; void introduce()&#123; System.out.println(\"我的名字叫 \" + this.name + \"，我的年龄 \" + this.age); &#125;&#125; 2.新建一个名为Student.java的Java源文件： 1234567891011121314151617class Student extends Person&#123; int grade; Student()&#123; System.out.println(\"Student的无参数构造函数\"); &#125; Student(String name, int age, int grade)&#123; // 调用父类Person当中的有两个参数name和age的构造函数 super(name, age); this.grade = grade; System.out.println(\"Student的有参数构造函数\"); &#125; void study()&#123; System.out.println(\"我学习的年级是 \" + this.grade); &#125;&#125; 3.新建一个名为Demo01.java的Java源文件： 12345678class Demo01&#123; public static void main(String[] args) &#123; Student stu01 = new Student(\"zhang3\",18,3); stu01.eat(); stu01.introduce(); stu01.study(); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程5.2之继承（extends）基础","slug":"monkey-java-basic-courses-5-2","date":"2015-07-15T03:00:27.000Z","updated":"2016-05-13T20:09:34.000Z","comments":true,"path":"2015/07/15/monkey-java-basic-courses-5-2/","link":"","permalink":"http://sunjiajia.com/2015/07/15/monkey-java-basic-courses-5-2/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 什么是继承 为什么要使用继承 继承的基本语法特点 继承的概念和格式 现实世界中，打个比方，继承就是富二代，就是儿子得到并使用老子的东西； 面向对象的世界中，继承就是一个类得到了另外一个类当中的成员变量和成员方法。 格式：12345678910class A&#123; 语句；&#125;class B extends A&#123; 语句；&#125;class C extends A&#123; 语句1； 语句2；&#125; 注意：Java中只允许单继承，不允许多继承。 例子：（请动手） 1.新建一个名为Person.java的Java源文件： 123456789101112class Person&#123; String name; int age; void eat()&#123; System.out.println(\"吃东西\"); &#125; void introduce()&#123; System.out.println(\"我的名字叫 \" + this.name + \"，我的年龄 \" + this.age); &#125;&#125; 2.新建一个名为Student.java的Java源文件： 1234567class Student extends Person&#123; int grade; void study()&#123; System.out.println(\"我学习的年级是 \" + this.grade); &#125;&#125; 3.新建一个名为Demo01.java的Java源文件： 1234567891011121314151617181920class Demo01&#123; public static void main(String[] args) &#123; // Student类由于继承了Person， // 因此它具有了父类Person的name和age成员变量，以及eat()和introduce()成员方法， // 所以Student的对象stu01拥有这些属性和方法。这就是继承。 // 这就减少了重复代码（name和age以及eat()和introduce()）在Student类中再次出现。 Student stu01 = new Student(); stu01.name = \"zhang3\"; stu01.age = \"15\"; // Student类中的成员属性； stu01.grade = 7; stu01.eat(); stu01.introduce(); // Student类中的成员方法； stu01.study(); &#125;&#125; 为什么要使用继承特点：（理解了继承的优点，就知道了为什么要使用继承） 面向对象的终极目标就是要减少程序中的重复代码，而类的继承，就可以有效减少重复代码； 类的继承结合方法的重载，可以极大的减少重复代码； 子类继承父类，可以对父类的功能进行扩展，符合面向对象的编程思想。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程5.1之static关键字的作用","slug":"monkey-java-basic-courses-5-1","date":"2015-07-13T14:00:27.000Z","updated":"2016-05-13T20:09:38.000Z","comments":true,"path":"2015/07/13/monkey-java-basic-courses-5-1/","link":"","permalink":"http://sunjiajia.com/2015/07/13/monkey-java-basic-courses-5-1/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 静态成员变量的语法特点 静态函数的语法特点 静态代码块的语法特点 静态成员变量的语法特点 在定义成员变量的时候，在前面添加一个static关键字。 格式：static int i; 特点： 静态成员变量可以直接用类名来调用，格式为：类名.成员变量名； 所有的对象使用的静态变量是同一份，任何一个对象的静态变量被修改，那么其他对象的静态变量也会被修改。 静态、普通成员变量的区别： 看图：（理解） 图5-1-01。静态、普通成员变量 例子：（请动手加深理解） 1.新建一个名为Person.java的Java源代码文件： 123class Person&#123; static int i;&#125; 2.新建一个名为Demo01.java的Java源代码文件：1234567891011121314151617181920212223242526272829303132class Demo01&#123; public static void main(String[] args) &#123; Person p1 = new Person(); Person p2 = new Person(); // 调用静态成员变量， // 由于所有对象使用的静态变量是同一份，所以， // p1.i 和 p2.i 的值都是10。 Person.i = 10; System.out.println(\"p1的i的值为：\" + p1.i); System.out.println(\"p2的i的值为：\" + p2.i); System.out.println(\"=======分割线=======\"); Person.i = 20; System.out.println(\"p1的i的值为：\" + p1.i); System.out.println(\"p2的i的值为：\" + p2.i); System.out.println(\"=======分割线=======\"); // 由于所有对象使用的静态变量是同一份，所以， // 静态变量i的值先被p1.i = 30赋值为30， // 再被p2.i = 40赋值为40， // 最后，打印出来的p1.i和p2.i的值都为40。 p1.i = 30; p2.i = 40; System.out.println(\"p1的i的值为：\" + p1.i); System.out.println(\"p2的i的值为：\" + p2.i); &#125;&#125; 静态函数的语法特点 格式：static 返回值类型 函数名{} 特点： 静态函数量可以直接用类名来调用，格式为：类名.函数名()； 静态函数中不能使用非静态成员变量；（注意） 例子：（请动手） 1.新建一个名为Dog.java的Java源文件： 1234567891011121314class Dog&#123; String name; static String color; void shout01()&#123; System.out.println(\"Dog的名字是：\" + this.name); &#125; static void shout02()&#123; // 静态函数只能使用静态成员变量color。 System.out.println(\"静态函数shout02()，Dog的颜色是：\" + color); &#125;&#125; 2.新建一个名为Demo02.java的Java源文件：1234567891011class Demo02&#123; public static void main(String[] args) &#123; Person.name = \"小黄\"; Person.color = \"黄色\"; Dog.shout01(); // 用类名直接调用静态函数 Dog.shout02(); &#125;&#125; 静态代码块的语法特点 作用：主要作用是为静态变量赋值初始值。 格式：123static&#123; 语句；&#125; 特点： 没有名字，只有一个static； 静态代码块在装载当前所在类的时候执行。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程5.0之this的使用方法","slug":"monkey-java-basic-courses-5-0","date":"2015-07-13T08:34:27.000Z","updated":"2016-05-13T20:09:42.000Z","comments":true,"path":"2015/07/13/monkey-java-basic-courses-5-0/","link":"","permalink":"http://sunjiajia.com/2015/07/13/monkey-java-basic-courses-5-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： this的涵义 使用this调用成员变量和成员函数 使用this调用构造函数 this的涵义 this代表一个对象，它代表了调用当前类中的变量或者函数的对象。 使用this调用成员变量和成员函数例子：（请动手） 1.新建一个名为Person.java的Java源文件： 12345678class Person&#123; String name; void talk()&#123; // 这里的this就是一个Person的对象。 System.out.println(\"My name is \" + this.name); &#125;&#125; 2.新建一个名为Demo01.java的Java源文件： 123456789101112131415class Demo01&#123; public static void main(String[] args) &#123; Person p1 = new Person(); p1.name = \"zhang3\"; Person p2 = new Person(); p2.name = \"li4\"; // 由于Person类中的talk方法中，有了this.name的表达，用了this关键字， // 因此，当p1调用talk()方法时，this.name相当于p1.name; // 当p2调用talk()方法时，this.name相当于p2.name。 p1.talk(); p2.talk(); &#125;&#125; 使用this调用构造函数 格式：this(参数1,参数2); 它的作用是调用同一个类中的其他构造函数， this的()中有几个参数，就会调用有几个参数的构造函数。 注意：它必须放在当前构造函数的第一行。 例子：（请动手） 1.新建一个名为Dog.java的Java源文件： 123456789101112131415161718192021222324252627282930313233class Dog&#123; String name; int age; String color; Dog()&#123; System.out.println(\"无参数的构造方法\"); &#125; Dog(String name, int age)&#123; // 这里的this.name代表成员变量name，“=”后面的name就代表构造函数的参数name； this.name = name; this.age = age; System.out.println(\"2个参数的构造方法\"); &#125; Dog(String name, int age, String color)&#123; // （重点）使用this调用构造函数 // 格式：this(参数1,参数2); // 它的作用是调用同一个类中的其他构造函数， // this的()中有几个参数，就会调用有几个参数的构造函数 this(name, age); this.color = color; System.out.println(\"3个参数的构造方法\"); &#125; void shout()&#123; // 这里的this就是一个Person的对象。 System.out.println(\"Dog's name is \" + this.name); &#125;&#125; 2.新建一个名为Demo02.java的Java源文件：1234567class Demo02&#123; public static void main(String[] args) &#123; Dog dog1 = new Dog(\"小白\", 1, \"白色\"); System.out.println(\"=============我是分割线=============\"); Dog dog2 = new Dog(\"小黑\", 3); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程4.3之面向对象基础4","slug":"monkey-java-basic-courses-4-3","date":"2015-07-11T08:34:27.000Z","updated":"2016-05-13T20:09:46.000Z","comments":true,"path":"2015/07/11/monkey-java-basic-courses-4-3/","link":"","permalink":"http://sunjiajia.com/2015/07/11/monkey-java-basic-courses-4-3/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 函数的重载 构造函数的作用 函数的重载 在同一个类中允许函数的重名这种现象的出现，它有3个特征： 两个或者多个函数在同一个类当中； 函数名相同； 参数列表不同。 例子：（请动手） 1.新建一个名称为Demo01.java的java源文件。 12345678910111213class Demo01 &#123; void funDemo01() &#123; System.out.println(\"没有参数的funDemo01函数\"); &#125; // 这个funDemo01函数重载了上面的funDemo01函数，特点为： // 1. 两个funDemo01函数处于同一个类Demo01当中； // 2. 函数名相同，都为funDemo01； // 3. 参数不同，第2个funDemo01函数有了一个整型参数i。 void funDemo01(int i) &#123; System.out.println(\"有参数i的funDemo01函数，i的值是\" + i); &#125;&#125; 新建一个名称为Demo02.java的java源文件。 Demo02类演示了重载方法的调用。 1234567class Demo02 &#123; public static void main(String[] args) &#123; Demo01 demo01 = new Demo01(); demo01.funDemo01(); demo01.funDemo01(100); &#125;&#125; 构造函数的作用 用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中；一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们，即构造函数的重载。 特征： 没有返回值类型的定义； 构造函数的名字必须和类的名字完全保持相同； 例子：（请动手） 新建一个名称为Person.java的java源文件。 123456789101112131415class Person &#123; // 构造函数 Person()&#123; &#125; // 第二个构造函数，利用的原理是方法的重载 Person(String n, int a)&#123; name = n; age = a; &#125; String name; int age;&#125; 新建一个名称为Demo03.java的java源文件。123456789101112131415class Demo03 &#123; public static void main(String[] args) &#123; // 调用的是无参的构造方法 Person p1 = new Person(); p1.name = \"zhang3\"; p1.age = 15; System.out.println(\"p1的name是：\" + p1.name + \"，age是：\" + p1.age); // 调用的是有参的构造方法，哪个写法更加简单呢？ Person p2 = new Person(\"li4\", 18); System.out.println(\"p12的name是：\" + p2.name + \"，age是：\" + p2.age); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程4.2之面向对象基础3","slug":"monkey-java-basic-courses-4-2","date":"2015-07-11T07:34:27.000Z","updated":"2016-05-13T20:09:52.000Z","comments":true,"path":"2015/07/11/monkey-java-basic-courses-4-2/","link":"","permalink":"http://sunjiajia.com/2015/07/11/monkey-java-basic-courses-4-2/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 对象的使用方法 多对象的创建方法 匿名对象的创建和使用方法 对象的使用方法对象调用变量格式：1对象.变量 对象调用函数格式：1对象.函数() 例子：（请动手）1.创建一个名为Dog.java的java源文件：123456789class Dog &#123; String name; int age; String color; void jump &#123; System.out.println(\"dog jump\"); &#125;&#125; 2.创建一个名为Demo01.java的Java源文件，它包含主函数：123456789101112class Demo01 &#123; public static void main(String[] args) &#123; Dog dog = new dog(); dog.name = \"小白\"; dog.age = 3; dog.color = \"黑色\"; dog.jump(); System.out.println(\"名字是：\" + dog.name); &#125;&#125; 多对象的创建方法创建一个名为Demo02.java的Java源文件，它包含主函数： 例子：123456789101112131415161718class Demo02 &#123; public static void main(String[] args) &#123; Dog dog01 = new dog(); dog01.name = \"小白\"; dog01.age = 3; dog01.color = \"黑色\"; dog01.jump(); Dog dog02 = new dog(); dog02.name = \"小黄\"; dog02.age = 1; dog02.color = \"白色\"; dog02.jump(); System.out.println(\"名字是：\" + dog01.name); System.out.println(\"名字是：\" + dog02.name); &#125;&#125; 匿名对象的创建和使用方法 匿名对象只用一次。 创建一个名为Demo03.java的Java源文件，它包含主函数： 例子：123456class Demo03 &#123; public static void main(String[] args) &#123; new Dog().jump(); new Dog().name = \"小花\"; &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程4.1之面向对象基础2","slug":"monkey-java-basic-courses-4-1","date":"2015-07-11T06:34:27.000Z","updated":"2016-05-13T20:09:56.000Z","comments":true,"path":"2015/07/11/monkey-java-basic-courses-4-1/","link":"","permalink":"http://sunjiajia.com/2015/07/11/monkey-java-basic-courses-4-1/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 创建类的方法 创建对象的方法 对象和对象的引用 创建类的方法1234class 类名 &#123; 属性; 方法;&#125; 属性，也叫成员变量，主要用于描述类的状态； 方法，也叫成员方法，主要用于描述类的行为。 例子：（勤动手）123456789// Person是类名，首字母通常大写。class Person &#123; // 成员变量 int age = 18; // 成员方法，它可以访问同一个类中的成员变量。 void shout() &#123; System.out.println(\"oh,I am \" + age); &#125;&#125; 对象创建对象格式：1类名 对象名 = new 类名(); 对象的引用 对象，是引用数据类型。 例子：（请动手）1Person person = new Person(); 运行过程： Person person创建一个Person的引用person； new Person()创建一个Person的对象； =将创建的Person对象赋给这个引用person。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程4.0之面向对象基础1","slug":"monkey-java-basic-courses-4-0","date":"2015-07-11T02:34:27.000Z","updated":"2016-05-13T20:10:00.000Z","comments":true,"path":"2015/07/11/monkey-java-basic-courses-4-0/","link":"","permalink":"http://sunjiajia.com/2015/07/11/monkey-java-basic-courses-4-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下内容： 什么是面向对象 应该如何学习面向对象 面向对象的思维方式 目标：熟悉Java语言中的for循环的使用方法。 什么是面向对象 面向对象是一种编程方法； 面向对象是一种思维方式； 面向对象是一种编程语言。 面向对象的终极目标：消除应用程序中的重复代码。 应该如何学习面向对象 掌握一门面向对象语言的语法； 掌握面向对象的思维方式； 熟悉面向对象设计原则； 掌握面向对象设计模式。 面向对象的思维方式 首先确定谁来做，其次确定怎么做； 首先考虑整体，其次考虑局部； 首先考虑抽象，其次考虑具体。 总结 不要认为掌握了一门面向对象语言就是掌握了面向对象； 要习惯于将面向对象与现实世界做比较； 要有一颗面向对象的心。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程3.3之循环语句","slug":"monkey-java-basic-courses-3-3","date":"2015-07-10T04:34:27.000Z","updated":"2016-05-13T20:10:08.000Z","comments":true,"path":"2015/07/10/monkey-java-basic-courses-3-3/","link":"","permalink":"http://sunjiajia.com/2015/07/10/monkey-java-basic-courses-3-3/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下知识点： 循环结构 for循环语句 while循环语句 循环结构一张图看懂什么是循环结构： 图3.3.01。循环结构 for循环语句源码：（请动手）12345678910111213141516public class Demo01 &#123; public static void main(String[] args) &#123; System.out.println(\"准备进入for循环语句。\"); // 1. 执行 int i = 0; // 2. 判断i的值是否小于10（即执行i &lt; 10;）； // 3. 如果i &lt; 10 ，则执行&#123;&#125;中的语句； // 4. &#123;&#125;中的语句执行完毕后，执行 i++ ； // 5. 再次判断 i &lt; 10； // 6. 如果i依旧小于10，重复3~5的过程，这个过程就是循环； // 7. 如果i &gt;= 10 ，那么循环停止。 for(int i = 0; i &lt; 10; i++)&#123; System.out.println(i); &#125; System.out.println(\"for循环语句结束。\"); &#125;&#125; while循环语句源码：（请动手）123456789101112131415161718public class Demo02 &#123; public static void main(String[] args) &#123; System.out.println(\"准备进入while循环语句。\"); // 1. 执行 int i = 0; // 2. 判断i的值是否小于10（即执行i &lt; 10;）； // 3. 如果i &lt; 10 ，即i &lt; 10的值为true，则执行&#123;&#125;中的语句； // 4. 如果 i &lt; 10的值为false，则while循环结束。 int i = 0; while(i &lt; 10)&#123; System.out.println(i); i++; // 如果没有这一行，则成为while死循环。 &#125; System.out.println(\"while循环语句结束。\"); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程3.4之练习课","slug":"monkey-java-basic-courses-3-4","date":"2015-07-10T04:34:27.000Z","updated":"2016-05-13T20:10:04.000Z","comments":true,"path":"2015/07/10/monkey-java-basic-courses-3-4/","link":"","permalink":"http://sunjiajia.com/2015/07/10/monkey-java-basic-courses-3-4/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下两个练习： 练习1：打印100~200之间的所有素数。 练习2：用*在命令行中打印出金字塔图案。 目标：熟悉Java语言中的for循环的使用方法。 练习1源码：（请动手）12345678910111213141516public class Demo01 &#123; public static void main(String[] args) &#123; for(int i = 100; i &lt; 201; i++)&#123; boolean b = false; for(int j = 2; j &lt; i - 1; j++)&#123; int k = i % j; if(k == 0)&#123; b = true; &#125; &#125; if(!b)&#123; System.out.println(i); &#125; &#125; &#125;&#125; 作业1：请优化Demo01，提高程序效率。 练习2源码：（请动手）12345678910111213public class Demo02 &#123; public static void main(String[] args) &#123; for(int i = 1; i &lt; 5; i++)&#123; for (int j = 0; j &lt; 4 - i; j++) &#123; System.out.print(\" \"); &#125; for (int k = 0; k &lt; i; k++) &#123; System.out.println(\"* \"); &#125; System.out.println(\"\"); &#125; &#125;&#125; 作业2：如果要求大家编写一个程序，可以打印出任意行的金字塔图案，应该怎么做呢？ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程3.2之练习课","slug":"monkey-java-basic-courses-3-2","date":"2015-07-10T03:22:27.000Z","updated":"2016-05-13T20:10:12.000Z","comments":true,"path":"2015/07/10/monkey-java-basic-courses-3-2/","link":"","permalink":"http://sunjiajia.com/2015/07/10/monkey-java-basic-courses-3-2/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本节课程将学习以下知识点： 练习1：将学生的分数按照标准分为优、良、中、差四个级别。 练习2：猜拳游戏。 练习1： 创建一个名为Demo01的类； 在Demo类中加入主函数； 在主函数中定义一个整型变量，用于表示学生的分数； 使用if…else…结构对分数进行分级。 源码：（请动手）123456789101112131415161718public class Demo01 &#123; public static void main(String[] args) &#123; int score = 60; if (score &gt;= 85 &amp;&amp; score &lt;= 100) &#123; System.out.println(\"优秀\"); &#125; else if (score &gt; 75 &amp;&amp; score &lt;= 85) &#123; System.out.println(\"良好\"); &#125; else if (score &gt;= 60 &amp;&amp; score &lt;= 75) &#123; System.out.println(\"中等\"); &#125; else if (score &lt; 60) &#123; System.out.println(\"不及格\"); &#125; else if (score &gt; 100 || score &lt; 0) &#123; System.out.println(\"成绩不在正常范围内\"); &#125; &#125;&#125; 练习2： 创建一个名为Demo02的类； 在Demo类中加入主函数； 在主函数中定义两个char类型的变量，分别代表两个玩家的出拳； 使用if…else…结构对结果进行判断。 源码：（请动手）1234567891011121314151617181920212223242526272829303132public class Demo02 &#123; public static void main(String[] args) &#123; /** * 'a' 代表 石头； 'b' 代表 剪刀； 'c' 代表 布； */ char play01 = 'a'; char play02 = 'b'; if (play01 == 'a' &amp;&amp; play02 == 'a') &#123; System.out.println(\"平\"); &#125; else if (play01 == 'a' &amp;&amp; play02 == 'b') &#123; System.out.println(\"play01赢\"); &#125; else if (play01 == 'a' &amp;&amp; play02 == 'c') &#123; System.out.println(\"play02赢\"); &#125; else if (play01 == 'b' &amp;&amp; play02 == 'a') &#123; System.out.println(\"play02赢\"); &#125; else if (play01 == 'b' &amp;&amp; play02 == 'b') &#123; System.out.println(\"平\"); &#125; else if (play01 == 'b' &amp;&amp; play02 == 'c') &#123; System.out.println(\"play01赢\"); &#125; else if (play01 == 'c' &amp;&amp; play02 == 'a') &#123; System.out.println(\"play01赢\"); &#125; else if (play01 == 'c' &amp;&amp; play02 == 'b') &#123; System.out.println(\"play02赢\"); &#125; else if (play01 == 'c' &amp;&amp; play02 == 'c') &#123; System.out.println(\"平\"); &#125; &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程3.1之分支语句","slug":"monkey-java-basic-courses-3-1","date":"2015-07-09T11:22:27.000Z","updated":"2016-05-13T20:10:18.000Z","comments":true,"path":"2015/07/09/monkey-java-basic-courses-3-1/","link":"","permalink":"http://sunjiajia.com/2015/07/09/monkey-java-basic-courses-3-1/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 本届课程将学习以下知识点： 程序运行流程的分类 if…else…分支语句 switch分支语句 ##程序运行流程的分类 顺序结构 分支结构（今天重点） 循环结构 ##if…else…分支语句 结构1：1234567// 布尔类型表达式 为true，才会执行&#123;&#125;里面的句子if(布尔类型表达式)&#123; 语句1; 语句2; 语句3; ... ...&#125; 例子：（请动手）12345678public class Demo&#123; public static void main(String[] args) &#123; int i = 7; if (i &gt; 5 &amp;&amp; i &lt; 10) &#123; System.out.println(\"i的值在5与10之间\"); &#125; &#125;&#125; 结构2：12345678910111213// 布尔类型表达式 为true，才会执行&#123;&#125;里面的句子；// 为 false，将会执行else&#123;&#125;中的句子。if(布尔类型表达式)&#123; 语句1; 语句2; 语句3; ... ...&#125; else &#123; 语句4; 语句5; 语句6; ... ...&#125; 例子：（请动手）12345678910public class Demo&#123; public static void main(String[] args) &#123; int i = 7; if (i &lt; 5 ) &#123; System.out.println(\"i的值小于5\"); &#125; else &#123; System.out.println(\"i的值大于5\"); &#125; &#125;&#125; 结构3：12345678910111213141516171819202122232425262728// 布尔类型表达式 为true，才会执行&#123;&#125;里面的句子；// 为 false，将会执行else if&#123;&#125;中的句子，依次进行。if(布尔类型表达式)&#123; 语句1; 语句2; 语句3; ... ...&#125; else if(布尔类型表达式)&#123; 语句4; 语句5; 语句6; ... ...&#125; else if(布尔类型表达式)&#123; 语句7; 语句8; 语句9; ... ...&#125; else if(布尔类型表达式)&#123; 语句10; 语句11; 语句12; ... ...&#125; else &#123; 语句13; 语句14; 语句15; ... ...&#125; 例子：（请动手）123456789101112public class Demo&#123; public static void main(String[] args) &#123; int i = 12; if (i &lt; 5 ) &#123; System.out.println(\"i的值小于5\"); &#125; else if( i &gt;= 5 &amp;&amp; i &lt;= 10 ) &#123; System.out.println(\"i的值在5到10范围之间\"); &#125; else &#123; System.out.println(\"i的值大于11\"); &#125; &#125;&#125; ##switch分支语句 它的功能用if…else…都可以实现。 结构：123456789101112131415161718192021222324// 表达式 只允许这几种类型：byte、short、int、char// 如果 表达式 所执行的结果和case后面的常量N是一样的，// 那么就会进入当前case体，执行相应的语句N，后面的case体将不再执行。switch(表达式)&#123; case 常量1: 语句1; break; case 常量2: 语句2; break; case 常量3: 语句3; break; ... ... case 常量N: 语句N; break; // 如果所有的case体都没有被执行，那么执行default体。 // default体是可以省略不写，这时，如果所有case体都没有执行，将直接跳出switch循环。 [ default: 默认语句; ]&#125; 例子：（请动手）123456789101112131415161718192021public class Demo&#123; public static void main(String[] args) &#123; char c = 'a'; switch(c) &#123; case 'b': System.out.println('b'); break; case 'c': System.out.println('c'); break; //注意： 这个case体没有 break; 。体验break的作用。编程时需要加上的。 case 'a': System.out.println('a'); default: System.out.println('d'); &#125; &#125;&#125; 例子：（请动手）123456789101112public class Demo&#123; public static void main(String[] args) &#123; int i = 5; // 这是一个表达式，它的类型是int整型，它的值是10； int j = i + 5; // 请自己表述一下。 boolean b = i &lt; 10; System.out.println(i); System.out.println(j); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程3.0之运算符与表达式","slug":"monkey-java-basic-courses-3-0","date":"2015-07-04T14:22:27.000Z","updated":"2016-05-13T20:10:24.000Z","comments":true,"path":"2015/07/04/monkey-java-basic-courses-3-0/","link":"","permalink":"http://sunjiajia.com/2015/07/04/monkey-java-basic-courses-3-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） ##运算符的分类 算术运算符：+,-,*,/,%,++,– 关系运算符：&lt;,&gt;,&gt;=,&lt;=,==,!= 布尔逻辑运算符：!（逻辑或）,&amp;（逻辑与）,|（逻辑或）,^（逻辑异或）,&amp;&amp;（短路与）,||（逻辑或） 位运算符：&amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt; 赋值运算符：== 扩展赋值运算符：+=,-=,*=,/= 字符串连接运算符：+ ##各种运算符的使用方法 ###算术运算符：关于算术运算符就不多说了，因为我大中国的教育是从小就学加减乘除。 注意1： int i = 3/2;请问i的值是几？答：i的值是1。 一个运算的过程，它的结果的类型取决于这一次运算当中，所有操作数里面最大的操作数的类型。3/2.0就等于1.5。由于2.0是double类型，3是整型，double比int类型的表数范围要大，因此结果的类型应该是double类型。 注意2： i++ 和 ++i 的区别是什么？ 答：i++先将i的值参加运算后在将i加1；++i是将i加1后再参加运算。 例子：（亲手敲代码） 123456789101112public class Demo &#123; public static void main(String[] args)&#123; int i = 5; int j = i++ + 5; int h = 100; int k = ++h + 5; System.out.println(j); System.out.println(i); System.out.println(k); System.out.println(h); &#125;&#125; ###关系运算符 它得到的结果是布尔类型的值，也就是true或者false。例子：（亲手敲代码） 12345678910111213public class Demo &#123; public static void main(String[] args)&#123; int i = 5; int h = 100; int k = 5; boolean result01 = i &gt; h; boolean result02 = i != h; boolean result03 = i == k; System.out.println(result01); System.out.println(result02); System.out.println(result03); &#125;&#125; ###布尔逻辑运算符（重点） 它其实就是用来计算true或者false。 我们用一张图表来展示逻辑运算符的结果： 图3.0.01。逻辑运算符 例子：（请动手）1234567891011121314151617181920public class Demo&#123; public static void main(String[] args) &#123; boolean a = true; boolean b = false; boolean c = a &amp; b; boolean d = a &amp;&amp; b; System.out.println(c); System.out.println(d); int i = 5; // 注意： &amp; 两边的表达式都会运算 boolean e = i &gt; 6 &amp; i++ &gt; 7; // 注意：使用 &amp;&amp; 时，如果 i&gt;6为false，则i++&gt;7就不会运算了。 boolean f = i &gt; 6 &amp;&amp; i++ &gt; 7; System.out.println(e); System.out.println(f); System.out.println(i); &#125;&#125; 扩展赋值运算符例子：（请动手）12345678public class Demo&#123; public static void main(String[] args) &#123; int i = 5; i += 5; // 相当于i = i + 5; i *= 5; // 相当于i = i * 5; System.out.println(i); &#125;&#125; ##什么是表达式 概念：（实记） 表达式是符合一定语法规则的运算符和操作符的序列。 对表达式中操作数进行运算得到的结果称为表达式的值。 表达式的值的数据类型即为表达式的类型。 例子：（请动手）123456789101112public class Demo&#123; public static void main(String[] args) &#123; int i = 5; // 这是一个表达式，它的类型是int整型，它的值是10； int j = i + 5; // 请自己表述一下。 boolean b = i &lt; 10; System.out.println(i); System.out.println(j); &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程2.x之巩固练习","slug":"monkey-java-basic-courses-2-x-exercises","date":"2015-07-03T11:22:27.000Z","updated":"2016-05-13T20:10:28.000Z","comments":true,"path":"2015/07/03/monkey-java-basic-courses-2-x-exercises/","link":"","permalink":"http://sunjiajia.com/2015/07/03/monkey-java-basic-courses-2-x-exercises/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 练习：（请动手）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 注意：类名一定和java源文件的名称一致。即 Demo。 * * @author Monkey * */public class Demo &#123; public static void main(String[] args) &#123; // 布尔型 boolean b = false; boolean bb = true; System.out.println(\"b--&gt;\" + b + \"，bb--&gt;\" + bb); // 字符型 char c = 'a'; char cc = '猴'; System.out.println(\"c--&gt;\" + c); System.out.println(\"cc--&gt;\" + cc); /** * 1.整数字面量为整型int 2.小数字面量为双精度浮点型double */ // 数值型 byte b01 = 0; short s = 0; int i = 0; long l = 0; long ll = 1; float f = 0; float ff = 0.1f; // 注意写0.1就会报错（可能损失精度） double d = 0; System.out.println(\"b01--&gt;\" + b01); System.out.println(\"s--&gt;\" + s); System.out.println(\"i--&gt;\" + i); System.out.println(\"l--&gt;\" + l); System.out.println(\"ll--&gt;\" + ll); System.out.println(\"f--&gt;\" + f); System.out.println(\"ff--&gt;\" + ff); System.out.println(\"d--&gt;\" + d); /** * 数值型表数范围的关系： byte &lt; short &lt; int &lt; long &lt; float &lt; double * * 大范围类型的的变量和小范围类型的变量相互操作，就会产生“可能损失精度”的错误； * * 例如： int temp01 = 10; long temp02 = 100; temp01 = temp02; */ &#125;&#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程2.1之基本数据类型","slug":"monkey-java-basic-courses-2-1","date":"2015-07-03T03:22:27.000Z","updated":"2016-05-13T20:10:32.000Z","comments":true,"path":"2015/07/03/monkey-java-basic-courses-2-1/","link":"","permalink":"http://sunjiajia.com/2015/07/03/monkey-java-basic-courses-2-1/","excerpt":"","text":"##数值型包括以下几种： 类型 占用存储空间 范围 byte 1字节 -128~127 short 2字节 -2的15次方~ 2的15次方-1 int 4字节 -2的31次方~ 2的31次方-1 long 8字节 -2的63次方~ 2的63次方-1 例子:12int i = 3;long l = 3L; ##字符型(char) char类型数据用来表示通常意义上的字符；注意以下几点： 字符是由单引号包裹起来的单个字符； Java字符使用unicode字符集； unicode字符集是什么？ 它为每种语言的每个字符设定了统一并唯一的二进制码。 详细参见WiKi百科Unicode词条 例子：123char c = 'a';char cc = 'z';char ccc = '猴'; 问题：为何ccc和c变量都是合法的呢？回答：因为Java语言默认使用Unicode字符集，从而保证一个汉字和一个英文字母在计算机中占用的空间是一样的。 ##布尔型(boolean) boolean数据类型适用于逻辑运算，一般用于程序流程控制，在Java中只有2个值： true : 表示“真”； false : 表示“假”。 例子：12boolean b = false;boolean bb = true; ##浮点型 包括两种，float和double： 类型 占用存储空间 范围 float 4字节 -3.403E38~3.403E38 double 8字节 -1.798E308~1.798E308 例子：1float f = 0.38f; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"一个Demo学会用Android兼容包新控件","slug":"android-new-widgets-demo","date":"2015-07-02T14:29:27.000Z","updated":"2016-05-13T20:13:12.000Z","comments":true,"path":"2015/07/02/android-new-widgets-demo/","link":"","permalink":"http://sunjiajia.com/2015/07/02/android-new-widgets-demo/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 前言伟大的Google为Android推出了一系列的兼容包，最新的就是Design Support Library了，这里我们结合v7和v4中的几个控件，来主要学习Design Support Library中的几个新控件！一个Demo学会用它们！ 效果动图GIF： Design Support Library Demo 学习内容通过本实例可以学习到以下内容： Drawerlayout和NavigationView实现优雅的Google范儿侧边栏； 新控件CoordinatorLayout、AppBarLayout、Toolbar、FloatingActionButton的用法，以及Toolbar的渐变隐藏动画效果； 官方Tabs组件TabLayout和ViewPager结合实现主界面内容区域； SwipeRefreshLayout和RecyclerView结合实现下拉刷新，以及RecyclerView的数据适配器RecyclerView.Adapter的用法，还有RecyclerView中item的点击事件的实现方法； 卡片式CardView的用法； 类似Toast的新控件Snackbar的用法。 ##布局文件 在源码中学习Android，是有种身临其境的感觉的。 学习Android解释再多代码都没有用，因为解释过了还是不会用。因此，我们这里将布局文件XML源码贴出来供学习，放心，所有知识点都已经注释在源码中。 ###styles.xml源码12345678910111213141516&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"MyThemeBlue\"&gt;&lt;/style&gt; &lt;!-- 蓝色为主色调 --&gt; &lt;style name=\"MyThemeBlue\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!--选中状态icon的颜色和字体颜色--&gt; &lt;item name=\"colorPrimary\"&gt;@color/main_blue_light&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/main_blue_dark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/main_blue_light&lt;/item&gt; &lt;!--正常状态下字体颜色和icon颜色--&gt; &lt;item name=\"android:textColorPrimary\"&gt;@color/main_white&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; colorPrimary、colorPrimaryDark、colorAccent、textColorPrimary的含义，请看博文《Android L+ Theme 与 Toolbar 实例》。 主布局activity_my.xml源码（重点）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_drawerlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!-- 第一个位置 --&gt; &lt;!-- 你的主界面内容，必须放置在Drawerlayout中的第一个位置 根据自己的需要来放置控件， 例如：LinearLayout布局或者RelativeLayout布局； 也可以是单个控件， 如 TextView等 --&gt; &lt;include layout=\"@layout/content_main\" /&gt; &lt;!-- 第二个位置 --&gt; &lt;!-- 用来放Drawerlayout中的内容， 这里使用NavigationView来实现类似Google pLay中的侧滑栏效果， 必须在build.gradle中添加compile 'com.android.support:design:22.2.0'； 另外，如果不需要NavigationView效果， 也可以放置一个普通布局文件就是一个普通的侧滑栏了。 --&gt; &lt;!-- 注意： 如果使用NavigationView（其他控件也是一样）的特有属性，需要加上命名空间： xmlns:app=\"http://schemas.android.com/apk/res-auto\"； 另外，一定要添加android:layout_gravity=\"left\"属性。 --&gt; &lt;!-- 属性解析： app:headerLayout： NavigationView中头部的head部分的布局，是自己实现的； app:menu： 指定Nav中的Menu布局，就是自己写Menu中的按钮，要放在res/menu/文件夹下； app:itemTextColor： 用来设置Nav中，menu item的颜色选择器。 还有一些属性： 和itemTextColor用法一样，指定一个颜色选择器，实现不同的颜色效果。 app:itemIconTint: app:itemBackground: --&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/id_navigationview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:itemTextColor=\"@color/selector_nav_menu_textcolor\" android:layout_gravity=\"left\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; content_main.xml源码（重点）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- CoordinatorLayout是这次新添加的一个增强型的FrameLayout，通过它可以实现很多东西： 例如： 1.界面向上滚动逐渐隐藏Toolbar； 2.在其中可以放置浮动的View，就像Floating Action Button。--&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_coordinatorlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;!-- AppBarLayout跟它的名字一样，把容器类的组件全部作为AppBar。 将AppBarLayout放在CoordinatorLayout中，就可以实现滚动效果。 本例中，TabLayout在界面滚动时，随着Toolbar的逐渐隐藏，将占据Toolbar的位置， 达到节省屏幕空间，界面动画效果的目的。 --&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/id_appbarlayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;!-- 属性解析： app:theme：指定Toolbar的样式，包括ActionbarToggle和popupMenu的指示图标颜色 app:popupTheme：指定popupMenu溢出后的样式 app:title: 指定Toolbar中主Title的内容 --&gt; &lt;!-- app:layout_scrollFlags的意思是： 设置的layout_scrollFlags有如下几种选项： scroll: 所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。 enterAlways: 这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。 enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 exitUntilCollapsed: 当视图会在滚动时，它一直滚动到设置的minHeight时完全隐藏。 需要注意的是，后面两种模式基本只有在CollapsingToolbarLayout才有用， 而前面两种模式基本是需要一起使用的，也就是说，这些flag的使用场景，基本已经固定了。 --&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/id_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\" app:title=\"@string/toolbar_title\" /&gt; &lt;!-- Tabs选项卡，和ViewPager搭配使用可以增大界面的内容展示量，实现各种个性化分类内容展示而不互相干扰！ Google在Design support library中提供官方的Tab组件，它就是TabLayout。 相比Github上面开源的第三方库，这个更加简单易用。 有以下常用属性： app:tabGravity=\"fill\" 表示TabLayout中的Tabs要占满屏幕的width； app:tabSelectedTextColor：Tab被选中字体的颜色； app:tabTextColor：Tab未被选中字体的颜色； app:tabIndicatorColor：Tab指示器下标的颜色； --&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/id_tablayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabGravity=\"fill\" app:tabIndicatorColor=\"@color/main_white\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- 我们常用的ViewPager，不多说了。你会发现多了一个 app:layout_behavior 属性，没错， 如果你使用CoordinatorLayout来实现Toolbar滚动渐变消失动画效果，那就必须在它下面的那个控件中加入这个属性， 并且下面的这个控件必须是可滚动的。 当设置了layout_behavior的控件滑动时，就会触发设置了layout_scrollFlags的控件发生状态的改变。 --&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/id_viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;!-- 这是一个浮动按钮。由于FloatingActionButton是重写ImageView的， 所有FloatingActionButton拥有ImageView的一切属性。 属性介绍： app:backgroundTint : FAB的背景色。 app:elevation ：FAB的阴影效果。 app:rippleColor ：设置涟漪的颜色，默认是由背景色生成的暗色调，可以自己指定。 app:pressedTranslationZ ：FAB动画效果，在它被按下的时候阴影就会增大。 --&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/id_floatingactionbutton\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:src=\"@mipmap/ic_action_plusone\" app:backgroundTint=\"@color/main_blue_light\" app:elevation=\"6dp\" app:pressedTranslationZ=\"12dp\" app:rippleColor=\"@color/main_blue_dark\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; frag_main.xml源码（Fragment的布局）1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--SwipeRefreshLayout是伟大的Google在v4包中给出的下拉刷新组件。--&gt;&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_swiperefreshlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;!-- 使用RecyclerView需要在build.gradle中添加 compile 'com.android.support:recyclerview-v7:22.2.0' --&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/id_recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; item_main.xml源码（RecyclerView中item）123456789101112131415161718192021222324252627282930313233343536&lt;!-- CardView就是一个卡片样式的FrameLayout。 参数介绍： app:cardBackgroundColor : 背景颜色 app:cardCornerRadius ： 设置圆角。 app:cardElevation ： 阴影。 app:cardMaxElevation ： 最大阴影。 app:cardPreventCornerOverlap ： 在v20和之前的版本中添加内边距， 这个属性是为了防止卡片内容和边角的重叠。 app:cardUseCompatPadding ： 设置内边距，v21+的版本和之前的版本仍旧具有一样的计算方式--&gt;&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_cardview\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" app:cardBackgroundColor=\"@color/main_blue_light\" app:cardCornerRadius=\"4dp\" app:cardElevation=\"5dp\" app:cardMaxElevation=\"10dp\" app:cardPreventCornerOverlap=\"true\" app:cardUseCompatPadding=\"true\"&gt; &lt;TextView android:id=\"@+id/id_textview\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:layout_gravity=\"center\" android:gravity=\"center\" android:textColor=\"@color/main_white\" android:textSize=\"30sp\" /&gt;&lt;/android.support.v7.widget.CardView&gt; menu_nav.xml的源码（NavagationView中菜单）123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_menu_home\" android:icon=\"@mipmap/ic_home_white_48dp\" android:title=\"主页\" /&gt; &lt;item android:id=\"@+id/nav_menu_categories\" android:icon=\"@mipmap/ic_sort_by_alpha_white_48dp\" android:title=\"分类\" /&gt; &lt;item android:id=\"@+id/nav_menu_feedback\" android:icon=\"@mipmap/ic_message_white_48dp\" android:title=\"反馈\" /&gt; &lt;item android:id=\"@+id/nav_menu_setting\" android:icon=\"@mipmap/ic_settings_white_48dp\" android:title=\"设置\" /&gt; &lt;/group&gt;&lt;/menu&gt; header_nav.xml源码（NavagationView的head）12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"220dp\" android:background=\"@drawable/ic_user_background\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;!-- 一个显示圆形头像的自定义ImageView --&gt; &lt;com.sunjiajia.androidnewwidgetsdemo.view.RoundedImageView android:id=\"@+id/id_header_face\" android:layout_width=\"110dp\" android:layout_height=\"110dp\" android:scaleType=\"fitXY\" android:src=\"@drawable/author\" /&gt; &lt;TextView android:id=\"@+id/id_header_authorname\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/header_author_name\" android:textColor=\"@android:color/black\" android:textSize=\"16sp\" /&gt; &lt;TextView android:id=\"@+id/id_header_url\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/header_author_url\" android:textColor=\"@android:color/black\" android:textSize=\"18sp\" /&gt;&lt;/LinearLayout&gt; Java代码 Java代码写法比较简单，这里只给出RecyclerView.Adapter的写法（包括item点击事件）。 ###RecyclerView.Adapter写法源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.sunjiajia.androidnewwidgetsdemo.adapter;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.sunjiajia.androidnewwidgetsdemo.R;import java.util.ArrayList;import java.util.List;/** * Created by Monkey on 2015/6/29. */public class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyRecyclerViewHolder&gt; &#123; // 点击事件接口 public interface OnItemClickListener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position); &#125; public OnItemClickListener mOnItemClickListener; public void setOnItemClickListener(OnItemClickListener listener) &#123; this.mOnItemClickListener = listener; &#125; public Context mContext; public List&lt;String&gt; mDatas; public LayoutInflater mLayoutInflater; public MyRecyclerViewAdapter(Context mContext) &#123; this.mContext = mContext; mLayoutInflater = LayoutInflater.from(mContext); // 这里是模拟数据。 mDatas = new ArrayList&lt;&gt;(); for (int i = 'A'; i &lt;= 'z'; i++) &#123; mDatas.add((char) i + \"\"); &#125; &#125; /** * 创建ViewHolder */ @Override public MyRecyclerViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View mView = mLayoutInflater.inflate(R.layout.item_main, parent, false); MyRecyclerViewHolder mViewHolder = new MyRecyclerViewHolder(mView); return mViewHolder; &#125; /** * 绑定ViewHoler，给item中的控件设置数据 */ @Override public void onBindViewHolder(final MyRecyclerViewHolder holder, final int position) &#123; //点击事件在这里实现，主要是利用RecyclerView中填充的布局控件可以被点击这个原理 if (mOnItemClickListener != null) &#123; holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnItemClickListener.onItemClick(holder.itemView, position); &#125; &#125;); // 长点击事件 holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; mOnItemClickListener.onItemLongClick(holder.itemView, position); return true; &#125; &#125;); &#125; holder.mTextView.setText(mDatas.get(position)); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125;&#125; MyRecyclerViewHolder.java源码1234567891011121314151617181920package com.sunjiajia.androidnewwidgetsdemo.adapter;import android.support.v7.widget.RecyclerView;import android.view.View;import android.widget.TextView;import com.sunjiajia.androidnewwidgetsdemo.R;/** * Created by Monkey on 2015/6/29. */public class MyRecyclerViewHolder extends RecyclerView.ViewHolder &#123; public TextView mTextView; public MyRecyclerViewHolder(View itemView) &#123; super(itemView); mTextView = (TextView) itemView.findViewById(R.id.id_textview); &#125;&#125; 结语 在源码中学习Android，是有种身临其境的感觉的。 整个Demo的源码我放在了GitHub上，谢谢star一下~在看源码过程中如果发现什么问题，请在留言，看到一定回复。 源码地址：AndroidNewWidgetsDemo ##清纯妹子 清纯妹子 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"进阶","slug":"进阶","permalink":"http://sunjiajia.com/tags/进阶/"}]},{"title":"《Monkey Java》课程1.1之JDK环境配置","slug":"monkey-java-basic-courses-1-1","date":"2015-07-01T04:04:27.000Z","updated":"2016-05-13T20:10:52.000Z","comments":true,"path":"2015/07/01/monkey-java-basic-courses-1-1/","link":"","permalink":"http://sunjiajia.com/2015/07/01/monkey-java-basic-courses-1-1/","excerpt":"","text":"JDK下载 注意：JDK有多个版本，请注意按照系统架构选择相应版本。JDK官网下载地址 参考图1.1_01: 图1.1_01。JDK下载 JDK安装 JDK的安装一直点击“下一步”即可。安装后的JDK、JRE默认位置在 12C:\\Program Files\\Java\\jdk1.7.0_80C:\\Program Files\\Java\\jre7 配置环境变量安装后，检测环境变量是否配置好：打开命令行窗口，输入命令java -version回显如下则已配置好：1234C:\\Users\\Administrator&gt;java -versionjava version \"1.7.0_80-ea\"Java(TM) SE Runtime Environment (build 1.7.0_80-ea-b05)Java HotSpot(TM) 64-Bit Server VM (build 24.80-b07, mixed mode) 如若回显其它信息，则需要手动配置环境变量： 参见JDK1.8环境变量配置 Path环境变量的作用1操作系统外部命令搜索路径。例如：ipconfig等。 classpath环境变量的作用1类文件搜索路径。例如：在编译Demo.java后，会在当前文件夹下生成Demo.class，运行时java Demo中Demo就是指的class文件，之所以能找到Demo.class，是因为classpath中设置了“.” JDK目录下的东西有什么用1234567bin: java用到的所有命令（可执行文件）都在这里，例如javacdemo: java的一些官方例子sample: java的一些官方例子include: 里面是C语言程序jre: java运行时环境lib: java需要的包（library）文件src.zip: jdk的源码 什么是JRE123456全称为Java Runtime Environment，即Java运行时环境。包括以下部分： 1.JVM（Java Virtual Machine）： 它是由软件虚拟出来的一个计算机，因此实现了跨平台。参见图1.1。 2.Java平台核心类文件。以后遇到再讲。 3.其他支持文件。 图1.1。JVM的作用流程 清纯小妹 清纯小妹 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程2.0之变量","slug":"monkey-java-basic-courses-2-0","date":"2015-07-01T04:04:27.000Z","updated":"2016-05-13T20:10:46.000Z","comments":true,"path":"2015/07/01/monkey-java-basic-courses-2-0/","link":"","permalink":"http://sunjiajia.com/2015/07/01/monkey-java-basic-courses-2-0/","excerpt":"","text":"转发请注明出处：安卓猴的博客（http://sunjiajia.com） 什么是变量简单理解就是，在计算机中存储信息的东西。 什么是语法语法，就是一种规则，根据这种规则可以编写出正确的代码。 变量的声明1int age = 20; int 表示变量类型 age 表示变量名 = 表示赋值符号，不念“等于”，而念“赋值于”。整句念为“将20赋值于整型变量age” ; 英文分号，表示语句结束 这条语句使计算机分配足够的空间，用于存储一个整数型数据，它的名字是age。int是Java中定义的一种数据类型，专门用于存储一定大小的整数； 这条语句回答了2个问题： 存储数据的空间有多大 数据存储在什么位置 变量的类型Java中的变量有两种类型：基本数据类型、引用数据类型。 基本数据类型又称原始数据类型，包括数值型、字符型(char)、布尔型(boolean)；而数值型又包括整数类型(byte,short,int,long)、浮点类型(float,double)。 引用数据类型包括类(class)、接口(interface)、数组。 变量的命名规范语法规范 应该以字母、下划线或者美元符开头； 后面跟字母、下划线、美元符或者数字； Java变量名没有长度限制； Java变量名对字母大小写敏感 命名法则此方法称为驼峰命名法。 变量名应该用有意义的英文单词； 变量名如果只有一个单词，则所有的字母用小写； 变量名如果由多个英文单词组成，则从第二个单词开始，首字母用大写。 本节练习新建一个txt文件，将其名字连同扩展名更改为Attributes.java。 1234567891011121314public class Attributes&#123; public static void main(String[] args)&#123; // 变量声明的正确写法， // 但是Age，$age，_age不推荐 // 应按照 驼峰命名法 int age = 20; int myAge = 25; int Age = 30; int $age = 40; int _age = 50; // 错误写法，编译的时候会报错 // int 8age = 60; &#125; &#125; 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"《Monkey Java》课程1.0之前言","slug":"monkey-java-basic-courses-1-0","date":"2015-06-30T03:04:27.000Z","updated":"2016-05-13T20:10:56.000Z","comments":true,"path":"2015/06/30/monkey-java-basic-courses-1-0/","link":"","permalink":"http://sunjiajia.com/2015/06/30/monkey-java-basic-courses-1-0/","excerpt":"","text":"前言《Monkey Java》系列介绍了学习Android所必需的Java基础知识，是进一步学习《Monkey Android》课程的基础。 所涉及的Java知识属于入门级，仅仅为学习Android作铺垫。我们在《Monkey Java》这个课程中，从最简单的Java基本语法，基本数据类型开始学习，逐渐讲解Android开发中会经常用到的Java知识点。 学习对象 1.对Android开发有浓厚兴趣的； 2.没有Java基础的； 学习理念 只学有用的！珍惜那杀猪刀般的岁月！ 清纯小妹 清纯小妹 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"《Monkey Java》","slug":"《Monkey-Java》","permalink":"http://sunjiajia.com/categories/《Monkey-Java》/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"Java","slug":"Java","permalink":"http://sunjiajia.com/tags/Java/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"Android完整Api文档离线下载","slug":"android-api-document-download","date":"2015-06-24T01:08:33.000Z","updated":"2016-05-13T20:11:02.000Z","comments":true,"path":"2015/06/24/android-api-document-download/","link":"","permalink":"http://sunjiajia.com/2015/06/24/android-api-document-download/","excerpt":"","text":"有时我们需要在离线的情况下，阅读完整的Android官方文档。 ###下载地址 API Level 17 API Level 18 API Level 19 Android-L API doc API Level 22 ###OVeR ~~ 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android新手","slug":"Android新手","permalink":"http://sunjiajia.com/categories/Android新手/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"新手","slug":"新手","permalink":"http://sunjiajia.com/tags/新手/"}]},{"title":"Android L+ Theme 与 Toolbar 实例","slug":"android-material-theme-and-toolbar","date":"2015-06-19T08:51:52.000Z","updated":"2016-05-13T20:11:06.000Z","comments":true,"path":"2015/06/19/android-material-theme-and-toolbar/","link":"","permalink":"http://sunjiajia.com/2015/06/19/android-material-theme-and-toolbar/","excerpt":"","text":"前言随着Android L和M的发布，app的Material Design也逐渐普及。材料设计是良心之作，不仅逐渐推动Android琳琅满目的app界面的统一，而且使开发者更加关注app的功能，而非UI设计。于是乎，我也开始学习它，这里随着学习的进度会写相应的博文。 有关Material Design的学习资料还是Google的官方文档最好，这里给出有分享精神的小伙伴们的翻译项目Material Design 中文版,供大家学习与参考。 ##Android L +的Theme细心的朋友会发现，Material 的主题有：具体有什么效果，自己试下。 @android:style/Theme.Material @android:style/Theme.Material.Light @android:style/Theme.Material.Light.DarkActionBar 与之对应的向下（L -）兼容Theme: Theme.AppCompat Theme.AppCompat.Light Theme.AppCompat.Light.DarkActionBar Toolbar的用法Toolbar的引入又是一个良心之作啊，之前的actionbar实在难用，很不方便。下面就看下Toolbar的用法，以及状态栏沉浸的用法。 Toolbar就是一个ViewGroup简单一点儿说就是，使用Toolbar，需要在布局文件xml中引入：12345&lt;android.support.v7.widget.Toolbar android:id=\"@+id/toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:background=\"?attr/colorPrimary\" /&gt; 然后需要在Activity中使用它：12Toolbar mToolbar = (Toolbar) findViewById(R.id.toolbar);setSupportActionBar(mToolbar); Toolbar的定制先看看本实例中Toolbar的样子吧，然后再来说Toolbar的一些属性，如图： Toolbar与statusbar颜色属性详图 ####xml style属性： colorPrimaryDark：状态栏的颜色（可用来实现沉浸效果） colorPrimary: Toolbar的背景颜色 （xml中用android:background=”?attr/colorPrimary”指定） android:textColorPrimary：Toolbar中文字的颜色，设置后Menu Item的字体颜色也会跟随 colorAccent：图中没有示例出来，这个是例如EditText正在输入时，RadioButton选中时的颜色（自己动手试下） xml属性： app:title=”App Title”：Toolbar中的App Title app:subtitle=”Sub Title” ：Toobar中的小标题 app:navigationIcon=”@android:drawable/ic_menu_sort_by_size” ： 导航图标（注意和Logo的区别） ####用java代码设置：12345mToolbar.setTitle(\"App Title\"); //设置Toolbar标题mToolbar.setSubtitle(\"Sub Title\"); //设置Toolbar 副标题mToolbar.setLogo(R.mipmap.ic_launcher);//设置Toolbar的Logo//设置Toolbar的 导航图标mToolbar.setNavigationIcon(android.R.drawable.ic_menu_sort_by_size); 如图： Toolbar的属性设置 ###完整代码 源码下载：Toolbar实例源码下载 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"}]},{"title":"健身日记","slug":"fitness-notes","date":"2015-05-29T13:39:04.000Z","updated":"2016-05-13T20:11:12.000Z","comments":true,"path":"2015/05/29/fitness-notes/","link":"","permalink":"http://sunjiajia.com/2015/05/29/fitness-notes/","excerpt":"","text":"健身日记 身体是码（ge）字（ming）的本钱。没有一个好身体，这辈子不管拥有什么，都是个白搭啊。这篇博文会随着我的健身锻炼，每日更新运动内容，时刻鞭策懒惰的身体。 公元2015年05.01 ~ 05.13早上：跑步6km左右晚上：跑步6km左右其它：安排的组合操一组 05.14上午：卷腹250下下午：卷腹200下，仰卧起坐60下，哑铃手臂训练200下。晚上：跑步7km，平均6分/千米；结束后再次做卷腹100个，V字起50下。 05.15早上：跑步6km，卷腹100个，V字起50下。今天有点累，做的少。下午补上。下午：组合操胸&amp;三头，卷腹100下，V字起80下。今天实在是做不动，应该是没有休息好～！晚上：跑步7km，卷腹200下。 05.16早上：卷腹150下，V字起50下。下午：太累，没运动，怕伤身体。晚上：跑步7km，时间40分钟，速度有了较大提高；卷腹100下，V字起50下。 05.17休息一天。 05.18早上：跑步6.0km，本打算跑7，结果跑到5km下雨了。中午：突然想起腹肌撕裂者，做了一节，视频如下： 下午：腿臀组合操一组。晚上：快走5km。下午做俯卧后抬腿的时候，不小心拉疼了筋儿，所以选择快走。 05.19早上：跑步8km，卷腹100下。昨晚3点半才睡，5点半又起床了。下午：卷腹200个，3分21秒做完，也就是平均1秒/卷；肩膀组合操一节。晚上：跑步5km，快走2km。V Up做了50个。腹部有撕裂的感觉！ 05.20早上：快走30分钟。卷腹100下。上午半截儿时又100卷腹。晚上：跑步6km，快走2km，V Up 50个。 05.21早上：跑步6km。卷腹60个。腹部实在是撕裂的疼啊！10点做腹肌撕裂者～！下午：偷懒。。。晚上：快走3km。偷懒。。 05.22早上：睡了个懒觉下午：又补了个觉晚上：跑步7km。 05.23早上：睡了懒觉。也许是前一阵在量太大，这几天突然很累。上午：卷腹100个。下午：肩膀三头组合操一组。晚上：快跑6KM。 05.24早上：睡了懒觉。下午：200个卷腹晚上：快走3KM。 05.25早上：跑步5KM。卷腹200个。下午：卷腹200个，肩膀三头组合操一套。晚上：快走2KM。明天早上开始加大强度了！ 05.26早上：跑步6KM。负重2.7kg小哑铃卷腹，没有计数多少个，直到做不动为止下午：偷懒晚上：跑步4KM，快走1KM。 05.27早上：跑步5KM。卷腹120个。腹肌侧拉50个。下午：组合操半套。晚上：跑步5KM，拉伸20分钟。 05.28全天休息，为了回归时的运动质量提升。最近发现跑步距离与速度再难提升，发现是由于每天运动，身体一直处于疲惫状态，需要休息下，做个提升。 05.29早上：起来准备去运动了，没想到下雨了。今天如果天晴的话，就会去运动！下午：偷懒了。晚上：偷懒了！不该啊！ 05.30上午：早上有大雾！没能跑步，腾空卷腹150下，半晌儿再来150个！V up起100个！ 说明：每次运动完及时记录。有兴趣的可以一起讨论健身方方面面。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"生活点滴","slug":"生活点滴","permalink":"http://sunjiajia.com/categories/生活点滴/"}],"tags":[{"name":"健身","slug":"健身","permalink":"http://sunjiajia.com/tags/健身/"},{"name":"跑步","slug":"跑步","permalink":"http://sunjiajia.com/tags/跑步/"}]},{"title":"Ubuntu安装字体and切换默认字体","slug":"ubuntu-fonts","date":"2015-05-10T02:57:10.000Z","updated":"2016-05-13T20:11:18.000Z","comments":true,"path":"2015/05/10/ubuntu-fonts/","link":"","permalink":"http://sunjiajia.com/2015/05/10/ubuntu-fonts/","excerpt":"","text":"Ubuntu系统安装好后，默认字体对于中文的支持看上去不太美丽，于是很多朋友可能需要设置系统的默认字体为自己喜欢的字体。本文主要介绍如何解决这两个问题。 安装字体：以微软雅黑字体为例（其他的宋体、黑体等点阵字体都一样的），我们的雅黑字体文件是：msyh.ttf(常规字体)和msyhbd.ttf(微软雅黑加粗字体)，该字体可在widows目录的Fonts目录下找到，如果没有，也可以从网上下载。由于我是双系统，我直接从Win7中复制了 msyh.ttf和msyhbd.ttf （都在C:\\Windows\\Fonts下面，搜索即得）到Ubuntu里桌面上的文件夹font下（~/Desktop/font）。 1.在/usr/share/fonts/下新建文件夹 如：winFonts目录，准备把从windows下拷贝过来的字体都放在这个目录里，这里就是把雅黑字体msyh.ttf和msyhbd.ttf放进来： 1sudo mkdir -p /usr/share/fonts/winFonts 2.然后将字体文件拷贝到此文件夹下： 1sudo cp ~/Desktop/font/*.ttf /usr/share/fonts/winFonts/ 3.然后，改变权限: 1sudo chmod 755 /usr/share/fonts/winFonts/*.ttf 4.开始安装： 1234cd /usr/share/fonts/winFonts/sudo mkfontscale （创建雅黑字体的fonts.scale文件，它用来控制字体旋转缩放）sudo mkfontdir （创建雅黑字体的fonts.dir文件，它用来控制字体粗斜体产生）sudo fc-cache -fv （建立字体缓存信息，也就是让系统认识雅黑） 5.然后再用unity-tweak-tool或者ubuntu-tweak设置字体即可。 搬运自：原文链接 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"系统相关","slug":"系统相关","permalink":"http://sunjiajia.com/categories/系统相关/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://sunjiajia.com/tags/linux/"}]},{"title":"程序员也要有个好身体","slug":"daily-exercise","date":"2015-05-07T01:25:53.000Z","updated":"2016-05-13T20:11:26.000Z","comments":true,"path":"2015/05/07/daily-exercise/","link":"","permalink":"http://sunjiajia.com/2015/05/07/daily-exercise/","excerpt":"","text":"好身体是码字的前提一年前就开始一些简单的健身了，但是都没有完全坚持下来，总是断断续续的，因此没有效果。原因其实只有一个————懒。随着每天坐在电脑前的时间越来越长，颈椎、腰椎甚至臀部都开始有那么点儿的僵硬，时不时还疼上个一两天，懒字就在这时得到了升华————病。我们程序员或者和IT关系比较密切的工人，大多数都会慢慢的走进这个境界，听句劝：还没有把健身当回事儿的兄弟姐妹们要行动起来了。 有计划的健身5月当头，我就开始了健身计划，在微博上请教一个大号（@美女健身宝典），制定了前期的计划；计划月中旬进入状态之后，再次加大强度，开始腹肌撕裂者。 目标1：6月当头时，能初见形状，肚子上的赘肉消灭差不多；目标2：7月当头时，腹肌显现出来并有块状；目标3：8月当头时，（完成目标1、2再来填写）。 健身装备（入门级） 名称 价格 Adidas AdiPure M18103 训练鞋 ￥799 瑜伽垫一个 ￥49 哑铃套装一套 ￥249 仰卧板一个 ￥200 合计 ￥1297 如图： 运动装备1 运动计划 按照每天锻炼不同部位分组 我的安排是每天18：00左右开始，一天一个分组，轮流完继续循环。 部位 动作名称 运动量 胸、三头 —— 发力呼气，收回吸气，3～4组，每组20次 —— 平板哑铃卧推 —— —— 上斜哑铃卧推 —— —— 撑椅子俯卧撑 —— —— 坐姿哑铃飞鸟 —— —— 哑铃颈后臂屈伸 —— —— 俯身哑铃臂屈伸 —— 部位 动作名称 运动量 背、二头 —— 发力呼气，收回吸气，3～4组，每组20次 —— 俯身哑铃划船 —— —— 双臂反卧划船 —— —— 屈腿硬拉 —— —— 锤土弯举 —— —— 坐姿集中弯举 —— —— 旋转弯举 —— 部位 动作名称 运动量 肩膀 —— 发力呼气，收回吸气，3～4组，每组20次 —— 肩上推举 —— —— 侧平举 —— —— 前平举 —— —— 俯身飞鸟（俯身侧平举） —— —— 开肘划船（wide raw） —— 部位 动作名称 运动量 腿，臀 —— 发力呼气，收回吸气，3～4组，每组20次 —— 哑铃深蹲 —— —— 哑铃酒杯蹲 —— —— 哑铃箭步蹲 —— —— 屈腿硬拉 —— —— 负重哑铃臀桥 —— —— 俯卧后抬腿 —— —— 提踵 —— 瘦肚子 坚持每天上午、下午各160个卷腹； 分组做，可以一次40个4组，或者其它组合。 定时跑步 我安排在每天早上、晚上各跑一次，每次7Km+，1h左右跑完，具体时间为： 早上5：00起床，“穿、洗、漱、拉”。“拉”是为了排除异物，跑步轻松； 晚上20：00左右，开始在附近的塑胶跑道跑步。 注意： 新手跑步如果跑不下来，可以分阶段跑，跑前记得充足热身拉伸，我的经历：4Km跑、1Km歇、3Km跑； 建议跑步之前学习下跑步要领，这里附上一个视频。 记录运动轨迹每流下一滴汗水，就会有一份收获，人生如此，健身亦是如此。因此，一定要使用自己习惯的方式来记录自己的运动轨迹。 1.跑步时，要记录跑步的速度，时间，距离等重要数据，推荐是使用Nike Running或者咕咚。2.每次运动结束后，要及时记录运动的感受；我使用的方式是在电脑上新建一个txt文档。 结束语本打算在这篇文章末尾的文字，都用来记录我每天的运动轨迹，但是突然发现，有可能导致自己不成熟的健身经验误导广大火眼金睛般的程序员，所以还是免了吧； 程序员不易，身体健康不易，且码且运动。 不过我的跑步记录都会用Nike Running同步到我的微博上，各位跑友，我们可以在微博上交流，我的微博@安卓猴 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"生活点滴","slug":"生活点滴","permalink":"http://sunjiajia.com/categories/生活点滴/"}],"tags":[{"name":"健身","slug":"健身","permalink":"http://sunjiajia.com/tags/健身/"},{"name":"跑步","slug":"跑步","permalink":"http://sunjiajia.com/tags/跑步/"}]},{"title":"Android中shape的使用","slug":"android-shape-attribute","date":"2015-05-06T02:46:11.000Z","updated":"2016-05-13T20:11:30.000Z","comments":true,"path":"2015/05/06/android-shape-attribute/","link":"","permalink":"http://sunjiajia.com/2015/05/06/android-shape-attribute/","excerpt":"","text":"Android中的drawable resource的属性太多，进阶路上必须要记住啊 看了下面的一段code就明白了： 12345678910111213141516171819202122&lt;shape&gt; &lt;!-- 实心 --&gt; &lt;solid android:color=\"#ff9d77\"/&gt; &lt;!-- 渐变 --&gt; &lt;gradient android:startColor=\"#ff8c00\" android:endColor=\"#FFFFFF\" android:angle=\"270\" /&gt; &lt;!-- 描边 --&gt; &lt;stroke android:width=\"2dp\" android:color=\"#dcdcdc\" /&gt; &lt;!-- 圆角 --&gt; &lt;corners android:radius=\"2dp\" /&gt; &lt;!-- 间隔 --&gt; &lt;padding android:left=\"10dp\" android:top=\"10dp\" android:right=\"10dp\" android:bottom=\"10dp\" /&gt; &lt;/shape&gt; 稍微解释一下啊： solid： 实心，就是填充的意思 android:color 指定填充的颜色 gradient 渐变 android:startColor 起始颜色 android:endColor 结束颜色 android:angle 渐变角度，必须为45的整数倍。 （另外渐变默认的模式为android:type=&quot;linear&quot;，即线性渐变，可以指定 渐变为径向渐变，android:type=&quot;radial&quot;，径向渐变需要指定半径 android:gradientRadius=&quot;50&quot;） stroke 描边 android:width=&quot;2dp&quot; 描边的宽度 android:color 描边的颜色。 我们还可以把描边弄成虚线的形式，设置方式为： android:dashWidth=&quot;5dp&quot; 表示&apos;-&apos;这样一个横线的宽度 android:dashGap=&quot;3dp&quot; 表示之间隔开的距离 corners 圆角 android:radius 为角的弧度，值越大角越圆。 我们还可以把四个角设定成不同的角度，方法为： &lt;corners android:topRightRadius=&quot;20dp&quot; 右上角 android:bottomLeftRadius=&quot;20dp&quot; 右下角 android:topLeftRadius=&quot;1dp&quot; 左上角 android:bottomRightRadius=&quot;0dp&quot; 左下角 /&gt; 这里有个地方需要注意: bottomLeftRadius 右下角，而不是左下角,记得别搞错了 padding 间隔 这个就不用多说了，XML布局文件中经常用到。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"http://sunjiajia.com/categories/Android进阶/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sunjiajia.com/tags/Android/"},{"name":"进阶","slug":"进阶","permalink":"http://sunjiajia.com/tags/进阶/"}]},{"title":"加速gps搜星","slug":"accelerate-gps","date":"2015-05-04T12:30:56.000Z","updated":"2016-05-13T20:11:36.000Z","comments":true,"path":"2015/05/04/accelerate-gps/","link":"","permalink":"http://sunjiajia.com/2015/05/04/accelerate-gps/","excerpt":"","text":"我平时在调试Android代码时用的设备是酷派大神F1联通版，这货其实很皮实，耐用，也比较耐摔，记得有一次不小心掉地上，紧接着右脚实打实地踩在屏幕上，心想这次该换个设备了，没想到拿起来还活的好好的！ 不过这家伙最让人头疼地就是酷派定制的ROM，它的Cool UI实在难用并且不好看。所以它很自然的成了小玩具，平时跑步时会拿着它用Nike Running来记录轨迹。 最近做了个小App赚点儿外快儿，刷了个第三方MIUI ROM，结果第二天早上跑步时，发现死活定不了位，gps搜不到星，急人啊。 回来修改了一下gps配置文件，就立马解决了gps搜星慢、gps定位慢的问题。想着博客新开张，还没有东西，顺便记录下吧，添个砖，明天再添个瓦，博客就丰富了。 用R.E文件管理或者ES文件浏览器在ROOT状态下打开并编辑/system/etc/gps.conf文件，清空后加入下面代码（最好备份下原文件）： 123456789101112131415NTP_SERVER=3.cn.pool.ntp.orgNTP_SERVER=0.cn.pool.ntp.orgNTP_SERVER=1.cn.pool.ntp.orgNTP_SERVER=2.cn.pool.ntp.orgNTP_SERVER=0.asia.pool.ntp.orgNTP_SERVER=1.asia.pool.ntp.orgNTP_SERVER=2.asia.pool.ntp.orgNTP_SERVER=3.asia.pool.ntp.orgXTRA_SERVER_1=http://xtra1.gpsonextra.net/xtra.binXTRA_SERVER_2=http://xtra2.gpsonextra.net/xtra.binXTRA_SERVER_3=http://xtra3.gpsonextra.net/xtra.binSUPL_HOST=suplcn.sirf.comSUPL_HOST=221.176.0.55SUPL_HOST=supl.google.comSUPL_PORT=7275 最后一行的7275，在有些设备上可能是7276,自己可以试下。 改完后确保gps.conf文件还是rw-r-r权限。 重启下设备，下载个GPS Testapp搜下星。 我这样修改后，可以秒定，建议在使用GPS定位地时候，移动网络不要关闭，这样搜星定位更快。 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"系统相关","slug":"系统相关","permalink":"http://sunjiajia.com/categories/系统相关/"}],"tags":[{"name":"gps","slug":"gps","permalink":"http://sunjiajia.com/tags/gps/"}]},{"title":"新博客前言","slug":"new-blog-preface","date":"2015-05-03T10:31:20.000Z","updated":"2016-05-13T20:11:42.000Z","comments":true,"path":"2015/05/03/new-blog-preface/","link":"","permalink":"http://sunjiajia.com/2015/05/03/new-blog-preface/","excerpt":"","text":"安卓猴新博客开通了！自我介绍～大家好，我叫孙佳佳(boy)，网名安卓猴，英文名字是Android Monkey。 从2014年8月份左右开始从零学习Android开发，中间断断续续的也学习了有3个多月了到现在，能做一些非常简单的app。自从能做出一些十分简单的app以后，我就开始将它们发布到各种app市场，也有一定地广告收入。 现在想开发一些上档次、拿得出手的app，感觉自己知识和技术都太嫩，于是开始了Android进阶之旅，希望和大家多多讨论，共同进步。 这个博客就是要记录我在进阶过程中学习到的值得和大家分享的有价值的东西，或者讨论一些有趣的问题。 经过这么一段时间的和Android打交道，深深喜欢上了它，也是我最兴趣的方向了。 说说计划～ 首先，还是从头开始屡屡吧，会发几篇博文，说说自己从学习Java到Android整个过程所使用的资料和视频。 其次，介绍一些我用过的好用的开源库（library）。 最后，最重要的是学习和记录更深层次的Android知识和技术。 怎样找到安卓猴？为了讨论方便，我新建了一个QQ群：186631885 为了接受邮件方便，现在我使用outlook邮箱：androidmonkey(#)outlook.com 为了关注大牛们地动态，我的新浪微博：http://weibo.com/androidmonkey 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[{"name":"生活点滴","slug":"生活点滴","permalink":"http://sunjiajia.com/categories/生活点滴/"}],"tags":[{"name":"前言","slug":"前言","permalink":"http://sunjiajia.com/tags/前言/"}]},{"title":"Hello World","slug":"hello-world","date":"2015-05-01T16:00:00.000Z","updated":"2016-05-13T20:11:48.000Z","comments":true,"path":"2015/05/02/hello-world/","link":"","permalink":"http://sunjiajia.com/2015/05/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 关于我 微博：@安卓猴 微信公众号：Android奇想录（android_amazing） 扫描二维码关注公众号","categories":[],"tags":[]}]}